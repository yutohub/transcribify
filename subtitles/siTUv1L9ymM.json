[
  {
    "start": 160,
    "end": 4214,
    "text": "皆さん、2024 React初心者コースへようこそ。"
  },
  {
    "start": 4302,
    "end": 11654,
    "text": "このコースでは、reactとは何か、どのように動作するのか、そしてreactを使ってアプリケーションを構築する際にどのように考える必要があるのかをすぐに学ぶことができます。"
  },
  {
    "start": 11742,
    "end": 13566,
    "text": "初心者に優しいコースだ。"
  },
  {
    "start": 13638,
    "end": 25566,
    "text": "簡単なものから始め、段階を踏んでより高度なリアクトのコンセプトを学び、最近多くのプロジェクトで使われているtypescriptやtailwind CSSも使っていきます。"
  },
  {
    "start": 25638,
    "end": 29326,
    "text": "すぐにでも使いこなしたいのであれば。"
  },
  {
    "start": 29398,
    "end": 42898,
    "text": "このチュートリアルでは、reactのプロジェクトを整理する方法、コードを小さなコンポーネントに分割する方法、さらに独自のカスタムフックを作成する方法についても学びます。"
  },
  {
    "start": 42954,
    "end": 47522,
    "text": "また、その過程でよくある反応ミスとその解決法も学ぶ。"
  },
  {
    "start": 47586,
    "end": 50386,
    "text": "このチュートリアルの前提条件は何ですか？"
  },
  {
    "start": 50458,
    "end": 56042,
    "text": "まあ、JavaScript、HTML、CSSの基本的な知識があれば完璧だろう。"
  },
  {
    "start": 56146,
    "end": 57098,
    "text": "そうでなくてもね。"
  },
  {
    "start": 57154,
    "end": 62882,
    "text": "ウェブ開発の全くの初心者でも、このチュートリアルについていけるかもしれない。"
  },
  {
    "start": 62946,
    "end": 68638,
    "text": "あちこちで基本的なことを調べる必要があるかもしれないが、そのときはいつでもGoogleを使うことができるし、後でギャップを埋めることもできる。"
  },
  {
    "start": 68734,
    "end": 70182,
    "text": "チュートリアルを終えたら"
  },
  {
    "start": 70246,
    "end": 74534,
    "text": "react、typescript、tailwindについての予備知識は必要ありません。"
  },
  {
    "start": 74582,
    "end": 76590,
    "text": "このチュートリアルでは、このすべてを学ぶ。"
  },
  {
    "start": 76670,
    "end": 79686,
    "text": "ここで、これから作るプロジェクトをざっと見てみよう。"
  },
  {
    "start": 79758,
    "end": 96514,
    "text": "なぜなら、リアクトの基本を本当に理解することが重要で、見栄えのする巨大なプロジェクトをただコピーするのではなく、結局は複雑すぎて何も学べないからだ。"
  },
  {
    "start": 96602,
    "end": 102914,
    "text": "完璧なreact初心者のプロジェクトは、単純なToDoリストアプリで、ToDoを削除することができます。"
  },
  {
    "start": 103042,
    "end": 109826,
    "text": "画面にはいくつかの情報があり、DOSを削除したり、新しいDOSを追加したりできる。"
  },
  {
    "start": 109898,
    "end": 113322,
    "text": "これは、反応がどのように働くかについて、多くのことを教えてくれるだろう。"
  },
  {
    "start": 113386,
    "end": 119484,
    "text": "このプロジェクトを通して、リアクターについて多くを学ぶことができるだろう。"
  },
  {
    "start": 119612,
    "end": 125396,
    "text": "もうひとつ、始める前に、無料のベストプラクティス・ミニEメールコースがあります。"
  },
  {
    "start": 125508,
    "end": 128980,
    "text": "このコースは、この初心者向けチュートリアルを完璧に補完するものだ。"
  },
  {
    "start": 129060,
    "end": 131060,
    "text": "ぜひ登録されることをお勧めする。"
  },
  {
    "start": 131100,
    "end": 143452,
    "text": "it@codinginflow.com リアクトのベストプラクティスを見つけることができます。これは短いEメールコースで、毎日小さなレッスンが送られてきます。"
  },
  {
    "start": 143516,
    "end": 146296,
    "text": "とても楽しいし、ついていくのはとても簡単だ。"
  },
  {
    "start": 146388,
    "end": 150392,
    "text": "さて、それではイデのリアクションを学び始めよう。"
  },
  {
    "start": 150496,
    "end": 159064,
    "text": "コードを書き込むソフトウェアには、ウェブ開発で最もよく使われているコード・エディターである対コードを使うことにする。"
  },
  {
    "start": 159232,
    "end": 163928,
    "text": "ダウンロードし、インストールするだけで使用できる。"
  },
  {
    "start": 164024,
    "end": 167936,
    "text": "次に、reactアプリを実行するには、node JSもインストールする必要がある。"
  },
  {
    "start": 168008,
    "end": 178278,
    "text": "コマンドラインウィンドウを開き、node v（バージョンの略）と入力すれば、node JSがすでにシステムにインストールされているかどうかを確認できる。"
  },
  {
    "start": 178374,
    "end": 181782,
    "text": "ノード20.9がインストールされていることがわかります。"
  },
  {
    "start": 181886,
    "end": 192198,
    "text": "nodeが認識されないと表示された場合、またはバージョンが18以下の場合は、nodejs.orgにアクセスし、最新のLTSバージョンをダウンロードしてインストールしてください。"
  },
  {
    "start": 192294,
    "end": 194670,
    "text": "LTSはロングターム・サポートの略。"
  },
  {
    "start": 194830,
    "end": 200110,
    "text": "つまり、このバージョンは数年間はバグフィックスとセキュリティパッチを受けられるということだ。"
  },
  {
    "start": 200230,
    "end": 205974,
    "text": "繰り返しになるが、少なくともノード18が必要なので、最新のLTSバージョンをインストールするのがいいだろう。"
  },
  {
    "start": 206102,
    "end": 217822,
    "text": "新しいリアクト・プロジェクトを構築する際には、何らかのフレームワークを使うことをお勧めする。そうすれば、プロジェクト全体を手作業で組み立てる必要がなくなるし、すべてを自分で配線する必要もなくなるからだ。"
  },
  {
    "start": 217926,
    "end": 230706,
    "text": "これはフルスタックのリアクト・フレームワークで、リアクトの上に、統合されたルーティング・システムやバックエンドのAPIルートなど、多くのクールな機能を追加している。"
  },
  {
    "start": 230838,
    "end": 234870,
    "text": "リアクトの基本を学ぶには、これはちょっとやりすぎだと思う。"
  },
  {
    "start": 235330,
    "end": 243034,
    "text": "その代わり、私はヴァイテを使いたい。ヴァイテには、私たちのためにプロジェクトを組み立ててくれるという利点がある。"
  },
  {
    "start": 243122,
    "end": 245786,
    "text": "同時にヴァイテはより骨太だ。"
  },
  {
    "start": 245858,
    "end": 250754,
    "text": "私たちはリアクトの上にたくさんの機能を載せているわけではなく、基本的にはリアクトだけを持っている。"
  },
  {
    "start": 250882,
    "end": 255434,
    "text": "次のJSでのプロジェクトの作り方を学びたい場合は、私の他のチュートリアルを見てください。"
  },
  {
    "start": 255522,
    "end": 259730,
    "text": "僕のチャンネルでは、クールなフルスタックプロジェクトをたくさん作っているよ。"
  },
  {
    "start": 259770,
    "end": 262072,
    "text": "ああ、ここではVitedeを使う。"
  },
  {
    "start": 262126,
    "end": 270080,
    "text": "このホームページでは、このようなビート・プロジェクトの作り方を紹介するスタート・ガイドを公開している。"
  },
  {
    "start": 270420,
    "end": 274908,
    "text": "実際には、コマンドラインで簡単なコマンドを実行するだけだ。"
  },
  {
    "start": 275084,
    "end": 279020,
    "text": "このプロジェクトを保存するフォルダに移動します。"
  },
  {
    "start": 279180,
    "end": 282924,
    "text": "デスクトップでも他のフォルダでも構わない。"
  },
  {
    "start": 283092,
    "end": 285636,
    "text": "ここでは、ウィンドウズでコマンドラインを開きたい。"
  },
  {
    "start": 285668,
    "end": 292330,
    "text": "シフトを押しながら右クリックし、Powershellまたはコマンド・ウィンドウを開く。"
  },
  {
    "start": 292450,
    "end": 296922,
    "text": "ここでは、ノード・パッケージ・マネージャーの略であるNPMと入力する。"
  },
  {
    "start": 296986,
    "end": 312898,
    "text": "node jsをインストールし、スペース・バイトを作成し、遅くともワイヤーでこれを確認した。"
  },
  {
    "start": 313034,
    "end": 315468,
    "text": "まず、このプロジェクトに名前をつけなければならない。"
  },
  {
    "start": 315594,
    "end": 320040,
    "text": "2024 React Beginnerと呼ぼう。"
  },
  {
    "start": 320080,
    "end": 321488,
    "text": "名前はあなた次第だ。"
  },
  {
    "start": 321664,
    "end": 323500,
    "text": "私たちはこれをエンターで確認している。"
  },
  {
    "start": 324120,
    "end": 329888,
    "text": "それからフレームワークを選択しなければならない。ヴァイトは実際には多くの異なるフレームワークと連動するからだ。"
  },
  {
    "start": 329944,
    "end": 333344,
    "text": "もちろん、バリアントにはリアクトを選びたい。"
  },
  {
    "start": 333392,
    "end": 336312,
    "text": "タイプスクリプトのバリエーションの一つを選びたい。"
  },
  {
    "start": 336416,
    "end": 337560,
    "text": "タイプスクリプトとは何か？"
  },
  {
    "start": 337640,
    "end": 340824,
    "text": "タイプスクリプトはJavaScriptのスーパーセットだ。"
  },
  {
    "start": 340912,
    "end": 343900,
    "text": "JavaScriptだが、その上に型が追加されている。"
  },
  {
    "start": 344000,
    "end": 348108,
    "text": "通常のJavaScriptの問題は、動的に型付けされていることだ。"
  },
  {
    "start": 348244,
    "end": 354204,
    "text": "どんな値でも関数に渡すことができるし、どんな値でも変数に入れることができる。"
  },
  {
    "start": 354332,
    "end": 359148,
    "text": "これは、特に大規模なプロジェクトでは、バグや問題を引き起こしやすい。"
  },
  {
    "start": 359204,
    "end": 365668,
    "text": "最近では、ほとんどの人がtypescriptを使用しており、実際に期待する値のみを渡すことができるようになっている。"
  },
  {
    "start": 365844,
    "end": 372158,
    "text": "例えば、ここではTodoオブジェクトの配列と宣言しているが、これはまさにこのような構造になっている。"
  },
  {
    "start": 372254,
    "end": 375726,
    "text": "Todoの完了値はブール値でなければならない。"
  },
  {
    "start": 375838,
    "end": 379902,
    "text": "文字列のような別の値を渡そうとすると、これはコンパイルされない。"
  },
  {
    "start": 379966,
    "end": 381766,
    "text": "アプリを起動することもできない。"
  },
  {
    "start": 381838,
    "end": 387030,
    "text": "これはいいことだ。なぜなら、これは間違いである可能性が高いからだ。"
  },
  {
    "start": 387150,
    "end": 395994,
    "text": "Typescriptは、バニラJavaScriptよりも少し多くのコードを書かなければならないが、その見返りとして得られる安全性は、本当に努力に値するものだ。"
  },
  {
    "start": 396102,
    "end": 399474,
    "text": "typeScriptを敬遠しないことをお勧めする。"
  },
  {
    "start": 399562,
    "end": 401954,
    "text": "初心者であっても、これを学ぶことには意味がある。"
  },
  {
    "start": 402082,
    "end": 410194,
    "text": "多くの初心者が最初の言語として使うJavaやKotlinのような他の言語も、この強力な型システムを持っている。"
  },
  {
    "start": 410322,
    "end": 414634,
    "text": "上級者向けのトピックではなく、基本的なトピックだと私は思う。"
  },
  {
    "start": 414722,
    "end": 421984,
    "text": "JavaScriptだけ始めて、typescriptは後で学ぼうと思わないで。"
  },
  {
    "start": 422122,
    "end": 426420,
    "text": "タイプスクリプトから始めれば、将来的に大きな恩恵を受けるだろう。"
  },
  {
    "start": 426540,
    "end": 429600,
    "text": "タイプスクリプトのSwzを選択。"
  },
  {
    "start": 429940,
    "end": 434812,
    "text": "Swzは、このアプリを少しだけ速くするために、ボンネットの下にあるいくつかのものだ。"
  },
  {
    "start": 434956,
    "end": 446532,
    "text": "タイプスクリプトSwCを選択し、Enterで確定すれば、一瞬で新しいプロジェクトが作成される。"
  },
  {
    "start": 446596,
    "end": 449120,
    "text": "これで実際にコマンドラインを閉じることができる。"
  },
  {
    "start": 449300,
    "end": 451760,
    "text": "これが新しいプロジェクト・フォルダーだ。"
  },
  {
    "start": 451880,
    "end": 456248,
    "text": "右クリックしてコードで開く。"
  },
  {
    "start": 456384,
    "end": 460384,
    "text": "このオプションがない場合は、対コードを直接開くこともできる。"
  },
  {
    "start": 460512,
    "end": 465592,
    "text": "ここでファイル・オープン・フォルダに移動し、この方法でプロジェクト・フォルダを開く。"
  },
  {
    "start": 465736,
    "end": 469240,
    "text": "そう、そしてこのようにリアクト・プロジェクトの準備が整った。"
  },
  {
    "start": 469320,
    "end": 473688,
    "text": "ご覧のように、私たちのためにかなりの数の設定ファイルを作成してくれた。"
  },
  {
    "start": 473784,
    "end": 481878,
    "text": "Srzフォルダにあるものはすべてreactのアプリケーションコードで、Srcフォルダ以外のファイルは設定ファイルです。"
  },
  {
    "start": 481974,
    "end": 486758,
    "text": "後でこのプロジェクトをコンパイルするとき、これも最適化され、高速になるだろう。"
  },
  {
    "start": 486934,
    "end": 490382,
    "text": "これがヴァイテのようなフレームワークが私たちに与えてくれるものなのだ。"
  },
  {
    "start": 490486,
    "end": 493566,
    "text": "ターミナルを開く。"
  },
  {
    "start": 493758,
    "end": 500254,
    "text": "このコマンドは、ビューアとターミナルで見つけることができる。"
  },
  {
    "start": 500422,
    "end": 503970,
    "text": "私はこのショートカットを使う。"
  },
  {
    "start": 504460,
    "end": 508480,
    "text": "それからNPMIまたはNPmインストールを実行する。"
  },
  {
    "start": 509020,
    "end": 511612,
    "text": "NPMIはその短いバージョンだ。"
  },
  {
    "start": 511796,
    "end": 516964,
    "text": "このパッケージJSONに記載されているいくつかのパッケージをインストールする。"
  },
  {
    "start": 517132,
    "end": 522440,
    "text": "これにはreact、いくつかのタイプスクリプト、その他の設定が含まれている。"
  },
  {
    "start": 522740,
    "end": 526400,
    "text": "Npm Iを使って、これらのパッケージをすべてインストールする。"
  },
  {
    "start": 526820,
    "end": 538006,
    "text": "これが終わったら、再びコマンドラインに入り、NPM run devを使って開発モードでプロジェクトを実行する。"
  },
  {
    "start": 538158,
    "end": 548370,
    "text": "そして、このlocalhostのURLにアクセスすると、このテンプレートがあり、このボタンをクリックすることで、自分のアプリに置き換えることができる。"
  },
  {
    "start": 548910,
    "end": 552958,
    "text": "すぐにコードを書き始めるが、いくつかのファイルを見てみよう。"
  },
  {
    "start": 553014,
    "end": 563120,
    "text": "このインデックスHTMLは、基本的に先ほど見たページで、HTMLタグ、メタデータを含むheadタグを含んでいる。"
  },
  {
    "start": 563240,
    "end": 566928,
    "text": "興味深いのは、このルート・タグの本体部分だ。"
  },
  {
    "start": 567024,
    "end": 572328,
    "text": "見ての通り、これはプロジェクト内の別のファイルであるメインのTSXを実行する。"
  },
  {
    "start": 572504,
    "end": 575456,
    "text": "この考え方に注目してほしい。"
  },
  {
    "start": 575608,
    "end": 591036,
    "text": "このメインTSXファイルには、インデックスHTMLのルート要素を検索するスクリプトがあり、ここでreactアプリをレンダリングし、reactはデフォルトでシングルページのアプリケーションを作成します。"
  },
  {
    "start": 591188,
    "end": 596092,
    "text": "私たちが持っているのは、このひとつの要素、いわばこのリアクト・ページだけだ。"
  },
  {
    "start": 596196,
    "end": 601900,
    "text": "例えば、画面上の何かが変わると、ルーターを経由して別のページに移動する。"
  },
  {
    "start": 602060,
    "end": 604356,
    "text": "そうすれば、まだ同じページを見ることができる。"
  },
  {
    "start": 604468,
    "end": 608588,
    "text": "リアクト・アプリをレンダリングするのは、まだインデックスのHTMLだ。"
  },
  {
    "start": 608684,
    "end": 609324,
    "text": "ただそれだけだ。"
  },
  {
    "start": 609372,
    "end": 613040,
    "text": "このアプリ・コンポーネントの中に入れるものは何でも変わる。"
  },
  {
    "start": 613140,
    "end": 620656,
    "text": "これは、サーバーにリクエストし、ページが返ってきて、このページを画面に表示するような古典的なウェブサイトとは異なる。"
  },
  {
    "start": 620688,
    "end": 623696,
    "text": "サーバーへのリクエストは基本的に1回だけだ。"
  },
  {
    "start": 623808,
    "end": 629600,
    "text": "私たちはこの1ページだけを返してもらい、それ以降のことはすべてJavaScriptで処理する。"
  },
  {
    "start": 629680,
    "end": 635808,
    "text": "JavaScriptはスクリーン上のコンテンツを置き換える。"
  },
  {
    "start": 635864,
    "end": 652250,
    "text": "クロームの開発ツールをf12で開き、ここでctrl shift pを押して無効なJavaScriptを検索し、開発ツールを開いたまま、f5でページを更新すると、ご覧のように何も表示されない。"
  },
  {
    "start": 652330,
    "end": 652666,
    "text": "なぜですか？"
  },
  {
    "start": 652738,
    "end": 659978,
    "text": "JavaScriptがなければ、メイン・スクリプトは実行されないし、リアクト・コンポーネントも画面に表示されないからだ。"
  },
  {
    "start": 660074,
    "end": 665258,
    "text": "デフォルトでは、reactアプリはJavaScriptなしでは動かない。"
  },
  {
    "start": 665354,
    "end": 669218,
    "text": "これは、next JSのようなフレームワークが解決する問題のひとつである。"
  },
  {
    "start": 669314,
    "end": 674890,
    "text": "サーバーサイド・レンダリングをリアクトに戻すことで、両方の長所を再び手に入れることができる。"
  },
  {
    "start": 674970,
    "end": 682922,
    "text": "私の他のチュートリアルで次のjsを学ぶこともできるが、まずはこの初心者向けチュートリアルを見てreactの基本を学ぶことをお勧めする。"
  },
  {
    "start": 683026,
    "end": 686818,
    "text": "それなら、次のjsのようなものに切り替えるのがいいと思う。"
  },
  {
    "start": 686954,
    "end": 693888,
    "text": "コマンドラインを閉じてページを再度更新すると、JavaScriptが再び有効になり、ページは再び機能する。"
  },
  {
    "start": 693994,
    "end": 699796,
    "text": "このコードがどこに隠されているかというと、アプリのTSXファイルにあるんだ。"
  },
  {
    "start": 699908,
    "end": 701476,
    "text": "これがこのカウンターだ。"
  },
  {
    "start": 701588,
    "end": 706028,
    "text": "使用状態の意味を理解する必要はない。"
  },
  {
    "start": 706204,
    "end": 708820,
    "text": "このカウンターを変更するボタンはこちら。"
  },
  {
    "start": 708940,
    "end": 717676,
    "text": "Reactはいわゆる宣言的UIアプローチを採用しているが、通常のJavaScriptアプリケーションは命令的アプローチを採用している。"
  },
  {
    "start": 717828,
    "end": 725074,
    "text": "リアクションを理解するためには、このことを理解する必要があるからだ。"
  },
  {
    "start": 725252,
    "end": 731014,
    "text": "派手なフレームワークを使わない普通のウェブアプリでは、コードは次のようになる。"
  },
  {
    "start": 731102,
    "end": 735070,
    "text": "HTMLファイルがあり、そこにさまざまなHTML要素がある。"
  },
  {
    "start": 735230,
    "end": 740326,
    "text": "例えば、カウンターの現在のカウントを表示するボタンがあります。"
  },
  {
    "start": 740358,
    "end": 746070,
    "text": "これは先ほど見たもので、J'sのバニラ・アプリでどのように書かれているかということだ。"
  },
  {
    "start": 746150,
    "end": 754190,
    "text": "そして別に、静的なHTMLファイルに実際に生命を吹き込むコードを実行できるJavaScriptファイルがある。"
  },
  {
    "start": 754310,
    "end": 760310,
    "text": "というのも、HTMLはそれ自体、テキストや画像を画面にレンダリングする以外に何もしないからだ。"
  },
  {
    "start": 760430,
    "end": 762918,
    "text": "すべてのロジックについてJ'sファイルが必要だ。"
  },
  {
    "start": 763014,
    "end": 765790,
    "text": "このJのファイルは次のようになる。"
  },
  {
    "start": 765910,
    "end": 772294,
    "text": "このcount変数を持っていて、例えば、ここで設定したアイデアからボタンを見つける。"
  },
  {
    "start": 772382,
    "end": 781530,
    "text": "このボタンにイベント・リスナーを追加し、クリック・イベントをリッスンし、ボタンをクリックするたびにカウンターをインクリメントし、ボタンのテキストを更新する。"
  },
  {
    "start": 781630,
    "end": 787434,
    "text": "このアプローチは命令形と呼ばれるが、それは私たちがやりたいことのすべての段階を説明しなければならないからだ。"
  },
  {
    "start": 787562,
    "end": 796186,
    "text": "まずボタンを見つけ、リスナーを追加し、カウントを増加させ、具体的にテキスト内容を更新しなければならない。"
  },
  {
    "start": 796378,
    "end": 801594,
    "text": "そうでなければ、ここのテキストは変更されず、この変数の最新値が反映されない。"
  },
  {
    "start": 801682,
    "end": 804562,
    "text": "そのために、すべてのステップを説明しなければならない。"
  },
  {
    "start": 804706,
    "end": 808050,
    "text": "これがreactが採用している宣言的アプローチだ。"
  },
  {
    "start": 808170,
    "end": 814018,
    "text": "これは、アプリのTSXファイルで見たコードで、興味のないものが取り除かれている。"
  },
  {
    "start": 814114,
    "end": 817690,
    "text": "そこでは、HTMLファイルとJavaScriptファイルを別々に持っていない。"
  },
  {
    "start": 817810,
    "end": 823770,
    "text": "そこで、ファイル名をJSXまたはTSXとし、これらすべてを1つのファイルにまとめる。"
  },
  {
    "start": 823850,
    "end": 830402,
    "text": "TSXはタイプスクリプトのことで、宣言的というのは、実行したいすべてのステップを説明しないということだ。"
  },
  {
    "start": 830466,
    "end": 836962,
    "text": "その代わり、画面に表示したいものだけを宣言すれば、あとはフードの下で自動的に行われる。"
  },
  {
    "start": 837066,
    "end": 842530,
    "text": "ここでは、カウンタがインクリメントされた後にテキストの内容を更新するとは言っていない。"
  },
  {
    "start": 842690,
    "end": 853842,
    "text": "その代わりに、この括弧の間にカウント値をレンダリングし、カウントの状態が変わるたびに自動的に更新され、最新の値が表示される。"
  },
  {
    "start": 853986,
    "end": 862572,
    "text": "命令型アプローチでは、常にこの操作を忘れないようにしなければならないからだ。"
  },
  {
    "start": 862716,
    "end": 864356,
    "text": "これは単純なケースだ。"
  },
  {
    "start": 864468,
    "end": 867172,
    "text": "画面上の情報をもっと変更したい場合は？"
  },
  {
    "start": 867236,
    "end": 880588,
    "text": "一方、宣言的アプローチでは、何を表示するかを宣言するだけで、自動的に常に最新の値が表示される。"
  },
  {
    "start": 880684,
    "end": 887304,
    "text": "reactは、ここの状態が変化するたびに画面全体を再描画することでこれを実現している。"
  },
  {
    "start": 887452,
    "end": 894152,
    "text": "これは非常に非効率的に聞こえるが、reactはフードの下でアップデートを最適化することによって、効率的な方法でこれを行う。"
  },
  {
    "start": 894256,
    "end": 900872,
    "text": "このカウンターをインクリメントした後、reactはこのボタンのカウントの最新値で画面を再描画するだけである。"
  },
  {
    "start": 900976,
    "end": 904992,
    "text": "私たちはこのことに気づかない。"
  },
  {
    "start": 905136,
    "end": 916680,
    "text": "このJSX構文のもう一つの利点は、マークアップ、ロジック、そしてtailwindではスタイリングも含む、カプセル化された再利用可能なコンポーネントを作成できることだ。"
  },
  {
    "start": 916800,
    "end": 927112,
    "text": "多くの異なるファイルを行き来する必要がなく、1つのファイルに必要なものをすべてまとめることができ、同時にコードの整理もしやすくなる。"
  },
  {
    "start": 927256,
    "end": 931168,
    "text": "ヴァイテのクールなところは、次のJSでもある。"
  },
  {
    "start": 931264,
    "end": 941060,
    "text": "ところで、ここで何かを変更するとき、たとえば、このボタンのテキストを変更して、開発モードを実行したまま保存しよう。"
  },
  {
    "start": 941360,
    "end": 946296,
    "text": "私たちはここですぐに変化を実感し、11回クリックした状態を維持することさえできる。"
  },
  {
    "start": 946408,
    "end": 949576,
    "text": "さあ、ハッキングを始める前にもうひと踏ん張りだ。"
  },
  {
    "start": 949688,
    "end": 952920,
    "text": "まだ追い風をセットしなければならないが、これはかなり簡単だ。"
  },
  {
    "start": 953080,
    "end": 958584,
    "text": "さて、通常CSSが機能するのは、要素にクラスを設定することだ。"
  },
  {
    "start": 958712,
    "end": 962448,
    "text": "例えば、この画像にはロゴ・クラスとリアクト・クラスがある。"
  },
  {
    "start": 962504,
    "end": 970608,
    "text": "唯一の違いは、reactではこのクラス名を引数として設定するのに対し、通常のHTMLではこれを単にclassと呼ぶことだ。"
  },
  {
    "start": 970784,
    "end": 979896,
    "text": "なぜなら、classはJavaScriptの予約キーワードであり、JSXファイルやTSXファイルは基本的にJavaScriptファイルだからだ。"
  },
  {
    "start": 979968,
    "end": 982016,
    "text": "これが、ここでクラス名と呼ばれる所以である。"
  },
  {
    "start": 982088,
    "end": 986816,
    "text": "1つだけ覚えておいてほしいのは、CSSファイルを分けていることだ。"
  },
  {
    "start": 986888,
    "end": 996024,
    "text": "例えば、このアプリのCSSは、これらのクラスのセレクタを持ち、CSS属性でこれらの引数をスタイルする。"
  },
  {
    "start": 996152,
    "end": 1003354,
    "text": "スタイリングを変更したい場合は、CSSファイルの属性を変更しなければならない。"
  },
  {
    "start": 1003442,
    "end": 1006050,
    "text": "Tailwind CSSは、そこでは少し違った働きをする。"
  },
  {
    "start": 1006090,
    "end": 1009138,
    "text": "私たちはもう、このような個別のCSSファイルは持っていません。"
  },
  {
    "start": 1009314,
    "end": 1015498,
    "text": "その代わりに、特定の役割を果たすさまざまなユーティリティクラスがたくさんある。"
  },
  {
    "start": 1015594,
    "end": 1019410,
    "text": "テキストを大きくしたい場合は、textlgのようなクラスがある。"
  },
  {
    "start": 1019570,
    "end": 1027356,
    "text": "パディングやマージン、特定の幅を追加したい場合は、異なる数値のクラスが用意されている。"
  },
  {
    "start": 1027458,
    "end": 1032168,
    "text": "この方法の利点は、TSXファイルを残す必要がなくなったことだ。"
  },
  {
    "start": 1032224,
    "end": 1036664,
    "text": "これらの異なるユーティリティ・クラスを使って、すべてのスタイリングを内部で直接行うことができる。"
  },
  {
    "start": 1036752,
    "end": 1041160,
    "text": "今、多くの人が追い風を気に入っているのは、追い風がより効率的だからだ。"
  },
  {
    "start": 1041280,
    "end": 1045472,
    "text": "嫌いな人も少なからずいるが、必要なスキルなので学ぶのは良いことだ。"
  },
  {
    "start": 1045536,
    "end": 1046420,
    "text": "最近はね。"
  },
  {
    "start": 1046840,
    "end": 1054008,
    "text": "ドキュメントには、このセットアップの方法が書かれている。"
  },
  {
    "start": 1054104,
    "end": 1060422,
    "text": "vitedeを検索してこのページを開き、いくつかのステップを踏む必要がある。"
  },
  {
    "start": 1060526,
    "end": 1062970,
    "text": "我々はすでにヴァイト・プロジェクトを立ち上げている。"
  },
  {
    "start": 1063510,
    "end": 1066094,
    "text": "次に、いくつかのパッケージをインストールしなければならない。"
  },
  {
    "start": 1066222,
    "end": 1082318,
    "text": "この行をコピーしてプロジェクトに戻り、コマンドラインをもう一度開いて、今devモードで実行しているアプリをcontrol zで停止させ、ワイヤで確認してから、これらのパッケージをインストールする。"
  },
  {
    "start": 1082414,
    "end": 1097912,
    "text": "このコマンドで、npmをコピーし、大文字のTaguin css post cssとauto prefixをインストールするだけで、これらの新しいパッケージがパッケージJSONファイルに入れられる。"
  },
  {
    "start": 1097936,
    "end": 1101424,
    "text": "これが終わったら、ここで彼らを見つけることができる。"
  },
  {
    "start": 1101592,
    "end": 1104048,
    "text": "インストール手順に戻ろう。"
  },
  {
    "start": 1104144,
    "end": 1110820,
    "text": "次に、NPX Terran CSS init peerというコマンドを実行する。"
  },
  {
    "start": 1111210,
    "end": 1120314,
    "text": "これもコマンドラインで実行し、プロジェクトのtailwind configとpost CSS configに新しいファイルを作成しよう。"
  },
  {
    "start": 1120442,
    "end": 1122110,
    "text": "では、それらについて見てみよう。"
  },
  {
    "start": 1122850,
    "end": 1126510,
    "text": "Tailwindの設定は、プロジェクトのルートにある。"
  },
  {
    "start": 1126970,
    "end": 1135898,
    "text": "その名の通り、ここではコンフィギュレーションを行うことができ、デフォルトのクラスを拡張したり、デフォルトのスタイルを追加したり、その他のコンフィギュレーションを行うことができる。"
  },
  {
    "start": 1135994,
    "end": 1141760,
    "text": "ここで、追い風ドキュメントの3番目のステップであるコピーもしなければならない。"
  },
  {
    "start": 1142340,
    "end": 1149620,
    "text": "この部分をtailwindコンフィギュレーションのコンテンツブロックにコピーしなければならない。"
  },
  {
    "start": 1149700,
    "end": 1151692,
    "text": "をこの配列に入れる。"
  },
  {
    "start": 1151876,
    "end": 1160916,
    "text": "これにより、インデックスのHTMLファイルや、JavaScriptのタイプスクリプト、JSX、TSXファイルすべてでtailwindが動作するようになります。"
  },
  {
    "start": 1161108,
    "end": 1164900,
    "text": "次に、これらの変更をコントロール SDE で保存します。"
  },
  {
    "start": 1165230,
    "end": 1180574,
    "text": "リンクのレンダリング方法、デフォルトで適用されているマージン、見出しの見え方などだ。"
  },
  {
    "start": 1180702,
    "end": 1194188,
    "text": "なぜなら、tailwindではこれらのコンポーネントはデフォルトでスタイルが設定されておらず、ユーティリティクラスを使って使用する場所でスタイルを設定するからです。"
  },
  {
    "start": 1194284,
    "end": 1203840,
    "text": "このファイルからすべてを削除し、代わりにこの3行を追加する。"
  },
  {
    "start": 1204460,
    "end": 1208068,
    "text": "ああ、これで追い風ユーティリティ・クラスを使う準備ができた。"
  },
  {
    "start": 1208204,
    "end": 1212468,
    "text": "また、Tailwindで動作するように、対コードを適切に設定したい。"
  },
  {
    "start": 1212564,
    "end": 1217978,
    "text": "そうでなければ、適切な自動補完を行わなければならないため、悪夢となる。"
  },
  {
    "start": 1218124,
    "end": 1226814,
    "text": "拡張機能タブを開き、公式のtailwind CSS intellisense拡張機能をインストールします。"
  },
  {
    "start": 1226942,
    "end": 1228806,
    "text": "このスクリーンショットでおわかりのように。"
  },
  {
    "start": 1228838,
    "end": 1236230,
    "text": "これは後で、クラス名文字列の中にあるさまざまなクラスを自動補完してくれるもので、非常に便利である。"
  },
  {
    "start": 1236310,
    "end": 1245850,
    "text": "これをインストールし、ファイルの関連付けを検索する対コードの設定を開く。"
  },
  {
    "start": 1246560,
    "end": 1256008,
    "text": "ここでは、アスタリスクCSSをキー、テールウインドCSSを小文字の1単語として、このファイルの関連付けを追加します。"
  },
  {
    "start": 1256144,
    "end": 1262140,
    "text": "これにより、Tailwind CSSがインデックスCSSのようなCSSファイル内で動作するようになります。"
  },
  {
    "start": 1262680,
    "end": 1265660,
    "text": "その場合、別の設定も変更しなければならない。"
  },
  {
    "start": 1266080,
    "end": 1274284,
    "text": "私たちは編集者の素早い提案を探し、ここでは文字列のためにこれをオンにしたい。"
  },
  {
    "start": 1274432,
    "end": 1279092,
    "text": "こうすることで、クラス名文字列のオートコンプリートを即座に実現できる。"
  },
  {
    "start": 1279236,
    "end": 1283172,
    "text": "そうでなければ、手動でトリガーをかけなければならない。"
  },
  {
    "start": 1283356,
    "end": 1287764,
    "text": "さて、最後に、Eslintエクステンションもインストールすることをお勧めします。"
  },
  {
    "start": 1287812,
    "end": 1291852,
    "text": "まだEslintが設定されていない場合は、自動的にEslintが設定されます。"
  },
  {
    "start": 1291956,
    "end": 1294844,
    "text": "これは、コード内の問題を見つけるのに役立つツールだ。"
  },
  {
    "start": 1294932,
    "end": 1303908,
    "text": "通常はコマンドラインから実行しなければならないが、この拡張機能を使えば、警告やエラーをエディター内で直接見ることができ、より便利だ。"
  },
  {
    "start": 1304044,
    "end": 1321628,
    "text": "オーケー、クールだ。エクスプローラーでアプリのcSSファイルをすべて削除しよう。"
  },
  {
    "start": 1321724,
    "end": 1324828,
    "text": "このファイルはもう存在しないので削除しよう。"
  },
  {
    "start": 1324964,
    "end": 1334872,
    "text": "もちろん、NPM run devを使って開発モードでアプリを再度実行すると、CSSを削除したためにスタイルが崩れてしまう。"
  },
  {
    "start": 1335056,
    "end": 1341656,
    "text": "興味深いことに、tailwindのデフォルトでは、ほとんどどの要素もデフォルトのスタイルを持たない。"
  },
  {
    "start": 1341808,
    "end": 1347344,
    "text": "例えば見出しやボタンは、通常CSSでデフォルトのスタイルが設定されている。"
  },
  {
    "start": 1347512,
    "end": 1352488,
    "text": "tailwindはこのデフォルトのスタイルを削除する。"
  },
  {
    "start": 1352584,
    "end": 1360962,
    "text": "もう一度index CSSファイルに入って、このtailwind baseディレクティブをコメントアウトすれば、デフォルトのスタイルを見ることができる。"
  },
  {
    "start": 1361096,
    "end": 1365918,
    "text": "これで、1990年のようなデフォルトのHTMLスタイルに戻った。"
  },
  {
    "start": 1366054,
    "end": 1371782,
    "text": "目が血走る前に、早くこれを戻して、自分でスタイリングしよう。"
  },
  {
    "start": 1371966,
    "end": 1377006,
    "text": "ここにあるように、このページはJavaScriptの関数でできている。"
  },
  {
    "start": 1377078,
    "end": 1380662,
    "text": "リアクトでは、UIの一部となるコンポーネントを作成する。"
  },
  {
    "start": 1380766,
    "end": 1385038,
    "text": "コンポーネントは、この場合のようにページ全体であることもあれば、小さな要素であることもある。"
  },
  {
    "start": 1385174,
    "end": 1387908,
    "text": "後ほど、さらに別のコンポーネントを作成する。"
  },
  {
    "start": 1388054,
    "end": 1400464,
    "text": "このreturn文の上にJavaScriptのロジックを置くことができ、return文の中にはさまざまなHTMLタグがあります。"
  },
  {
    "start": 1400592,
    "end": 1408860,
    "text": "このreturnブロックの中にあるものは、ここにある空のタグも含めてすべて削除し、代わりにここにメイン・タグを入れよう。"
  },
  {
    "start": 1410040,
    "end": 1416894,
    "text": "このメインタグには、Todoアプリを作ったので、あなたはTodoですという見出しを1つ付けます。"
  },
  {
    "start": 1417032,
    "end": 1419658,
    "text": "では、この未使用のものをすべて削除しよう。"
  },
  {
    "start": 1419714,
    "end": 1424430,
    "text": "今のところ、この日付は必要ないし、これらのインポート文はすべて取り除くことができる。"
  },
  {
    "start": 1424810,
    "end": 1428922,
    "text": "そして今、私たちの見出しがここにある。デフォルトではまったくスタイルがない。"
  },
  {
    "start": 1428986,
    "end": 1430346,
    "text": "では、このスタイルでいこう。"
  },
  {
    "start": 1430538,
    "end": 1434230,
    "text": "メイン・タグに最初にクラス名を追加することでこれを行う。"
  },
  {
    "start": 1435010,
    "end": 1441618,
    "text": "py tenでは、2.5remという値で垂直方向のパディングを追加することができる。"
  },
  {
    "start": 1441674,
    "end": 1445910,
    "text": "tailwindエクステンションをインストールしたため、カーソルを合わせるとこのように表示される。"
  },
  {
    "start": 1446460,
    "end": 1453020,
    "text": "これを保存すると、メインのタグに垂直方向のパディングが追加され、別のCSSファイルに書き込む必要がなくなった。"
  },
  {
    "start": 1453060,
    "end": 1460440,
    "text": "パディングを変更したい場合は、このファイルを残したまま、例えばpy 8のように別の値を追加することができる。"
  },
  {
    "start": 1460740,
    "end": 1465960,
    "text": "デフォルトでは、このメイン・タグは、その中のコンテンツと同じ大きさしかない。"
  },
  {
    "start": 1466740,
    "end": 1469660,
    "text": "スクリーンと同じ大きさにしたい。"
  },
  {
    "start": 1469820,
    "end": 1475142,
    "text": "これらのクラスはすべてTailwindによって提供されます。"
  },
  {
    "start": 1475206,
    "end": 1478198,
    "text": "ご覧のように、これらのクラスは山ほどある。"
  },
  {
    "start": 1478254,
    "end": 1483734,
    "text": "これで画面の高さがいっぱいになったので、この背景色をまた消したい。"
  },
  {
    "start": 1483902,
    "end": 1487730,
    "text": "同じように、私たちはHワンの見出しをスタイリングしなければならない。"
  },
  {
    "start": 1488230,
    "end": 1493130,
    "text": "このテキストを太字にしたい。"
  },
  {
    "start": 1493550,
    "end": 1494690,
    "text": "ほらね。"
  },
  {
    "start": 1495990,
    "end": 1503252,
    "text": "また、例えばtext three xlで大きくしたり、異なるサイズの値を指定することもできる。"
  },
  {
    "start": 1503396,
    "end": 1506600,
    "text": "テキスト・センターで画面の中央に配置することができる。"
  },
  {
    "start": 1507020,
    "end": 1509820,
    "text": "そう、これが追い風に隠されたマジックなんだ。"
  },
  {
    "start": 1509980,
    "end": 1515164,
    "text": "さて、アプリの残りの部分を作り続ける前に、もうひとつパッケージを追加しよう。"
  },
  {
    "start": 1515292,
    "end": 1528806,
    "text": "もう一度、ターミナルを開き、control zで実行を停止し、NPMIを再実行します。これは、Roset Reactという別のパッケージをインストールすることを意味します。"
  },
  {
    "start": 1528998,
    "end": 1531130,
    "text": "スペルを間違えないように。"
  },
  {
    "start": 1531630,
    "end": 1540890,
    "text": "このチュートリアルでは依存関係をできるだけ少なくしたい。"
  },
  {
    "start": 1541350,
    "end": 1547010,
    "text": "NPM run devでこれをもう一度実行してみよう。"
  },
  {
    "start": 1547430,
    "end": 1551858,
    "text": "また、依存関係ブロックにルーシッド・リアクトが追加された。"
  },
  {
    "start": 1552054,
    "end": 1563338,
    "text": "dependenciesブロックには、本番環境で必要なパッケージがすべて、dev dependenciesブロックには、後でプロジェクトをコンパイルするときに開発環境でだけ必要なパッケージがすべて入っている。"
  },
  {
    "start": 1563434,
    "end": 1568298,
    "text": "これらの依存関係は、アプリを実行するために実際に必要なものではないので、含めない。"
  },
  {
    "start": 1568394,
    "end": 1573866,
    "text": "必要なのは、eslintヘルパーやtypescriptのようなアプリを書くことだけだ。"
  },
  {
    "start": 1574018,
    "end": 1574794,
    "text": "オーケー、クールだ。"
  },
  {
    "start": 1574882,
    "end": 1577034,
    "text": "では、アプリのビルドを続けよう。"
  },
  {
    "start": 1577162,
    "end": 1579954,
    "text": "では、ToDoリストをスクリーンに表示しよう。"
  },
  {
    "start": 1580002,
    "end": 1583104,
    "text": "そのためにダミーのデータをファイルに入れたい。"
  },
  {
    "start": 1583202,
    "end": 1594156,
    "text": "reactでプロジェクトをどのように構成するかは個人の好み次第だが、アプリで直接使うものはすべて、この中のSrzフォルダに入れる。"
  },
  {
    "start": 1594188,
    "end": 1595612,
    "text": "新しいファイルを作成しよう。"
  },
  {
    "start": 1595716,
    "end": 1601240,
    "text": "そして、この方法でデータを書き込み、フォルダを作成する。"
  },
  {
    "start": 1601740,
    "end": 1610480,
    "text": "今回はTSXではなくtdos tsとしよう。"
  },
  {
    "start": 1610850,
    "end": 1614090,
    "text": "ここに次のような配列を置く。"
  },
  {
    "start": 1614170,
    "end": 1616898,
    "text": "ビデオを一時停止して、これを手書きしてください。"
  },
  {
    "start": 1616994,
    "end": 1621058,
    "text": "これらは、とりあえず画面に表示させたい3つのダミーのトドだ。"
  },
  {
    "start": 1621114,
    "end": 1625194,
    "text": "後で独自のTodoを追加することもできるが、今はこのハードコードされたデータを使う。"
  },
  {
    "start": 1625322,
    "end": 1631090,
    "text": "これでtypescriptは、ここに入れたデータだけで、この配列の型を自動的に推測できるようになった。"
  },
  {
    "start": 1631210,
    "end": 1631730,
    "text": "それは見えている。"
  },
  {
    "start": 1631770,
    "end": 1638962,
    "text": "さて、ここにあるすべての項目にはid（数字）、タイトル（文字列）、完了値（ブール値）がある。"
  },
  {
    "start": 1639066,
    "end": 1651586,
    "text": "ダミー・データにカーソルを合わせると、id番号、タイトル、文字列、完了したbooleanが表示される。このように型を推測することの問題点は、誤って間違ったデータを渡してしまうことを防げないことだ。"
  },
  {
    "start": 1651738,
    "end": 1662114,
    "text": "先ほどお見せしたように、ここで文字列を渡すと、completedの型はブーリアンか文字列のどちらかと推論される。"
  },
  {
    "start": 1662162,
    "end": 1663762,
    "text": "私たちはここにタイプの安全性を求めている。"
  },
  {
    "start": 1663866,
    "end": 1666858,
    "text": "私たちはタイプスクリプトにこのようなミスから守ってもらいたい。"
  },
  {
    "start": 1666954,
    "end": 1669304,
    "text": "明示的に型を設定したい。"
  },
  {
    "start": 1669442,
    "end": 1674412,
    "text": "この型をここで宣言することもできるが、また別のファイルに書こう。"
  },
  {
    "start": 1674476,
    "end": 1677252,
    "text": "どこに置くかは個人の好み次第だ。"
  },
  {
    "start": 1677396,
    "end": 1680920,
    "text": "もう一度、Srcフォルダに新しいファイルを作りたい。"
  },
  {
    "start": 1681380,
    "end": 1693732,
    "text": "今回はこのtypesフォルダを作成し、この中にtodo tsを入れて、新しいタイプを作成するために新しいインターフェイスをエクスポートする。"
  },
  {
    "start": 1693916,
    "end": 1699160,
    "text": "プロジェクト全体のさまざまなファイル内で使用するため、ここでエクスポートする。"
  },
  {
    "start": 1700100,
    "end": 1708516,
    "text": "このインターフェイスをtodoと呼び、中括弧を2つ作り、このインターフェイスや型がどのように見えるべきかを宣言する。"
  },
  {
    "start": 1708628,
    "end": 1711692,
    "text": "先ほど見たのと同じ構造を使っている。"
  },
  {
    "start": 1711836,
    "end": 1723680,
    "text": "すべてのTodoerに、数字型のアイデア、文字列型のタイトル、ブール値の完了値を持たせたい。"
  },
  {
    "start": 1724670,
    "end": 1732090,
    "text": "ダミーデータという変数名の後ろに行くことで、この型をここで使うことができる。"
  },
  {
    "start": 1732430,
    "end": 1739250,
    "text": "このファイルからTodoインターフェイスをインポートするcolon Todoを書く。"
  },
  {
    "start": 1739910,
    "end": 1743690,
    "text": "なら、これを角括弧付きの配列にしたい。"
  },
  {
    "start": 1743990,
    "end": 1755100,
    "text": "なぜならエラーが発生し、コンパイルすらできなくなるからだ。タイプミスの場合も同様である。"
  },
  {
    "start": 1756320,
    "end": 1768600,
    "text": "関数の引数も同様に、間違ったデータ型を関数に渡すことがないように型が設定されている。"
  },
  {
    "start": 1768760,
    "end": 1786938,
    "text": "このファイルを保存して、アプリのtsxファイルに戻ろう。mainタグ内のhの下にdivを置き、このdivの中に別のdivを置く。"
  },
  {
    "start": 1787114,
    "end": 1790834,
    "text": "ここでは、ダミーデータのリストをレンダリングしたい。"
  },
  {
    "start": 1790962,
    "end": 1792378,
    "text": "どうすればいいのか？"
  },
  {
    "start": 1792514,
    "end": 1800978,
    "text": "中括弧を追加すれば、JSXファイルのreturnブロックに直接JavaScriptコードを書くことができる。"
  },
  {
    "start": 1801154,
    "end": 1808894,
    "text": "これは基本的に、HTMLからJavaScriptへのウィンドウであり、ここにJavaScriptのロジックを入れることができる。"
  },
  {
    "start": 1809022,
    "end": 1813470,
    "text": "しかし、ここに入れるものは何でも、JSX要素を返さなければならない。"
  },
  {
    "start": 1813590,
    "end": 1818566,
    "text": "コンポーネントかこれらのHTMLタグのいずれかをここにレンダリングする。"
  },
  {
    "start": 1818678,
    "end": 1820610,
    "text": "表現でなければならない。"
  },
  {
    "start": 1821190,
    "end": 1829490,
    "text": "そこで、ダミー・データを書いて、データ・フォルダーからダミー・データ配列をインポートしてみよう。"
  },
  {
    "start": 1830120,
    "end": 1834500,
    "text": "このリコール・マップ上に、2つの括弧を作る。"
  },
  {
    "start": 1834800,
    "end": 1841552,
    "text": "ここではtodoと書き、等号と大なり記号で右矢印を作る。"
  },
  {
    "start": 1841696,
    "end": 1850728,
    "text": "なぜなら、ここでは何かを返したいからで、HTML要素を返したいからだ。"
  },
  {
    "start": 1850864,
    "end": 1863680,
    "text": "このようなto doをこのようにレンダリングするには、この配列全体を受け取り、このダミーデータの各todoを取り出したいので、これらのオブジェクトのそれぞれをUI要素に変えたいと言う。"
  },
  {
    "start": 1864020,
    "end": 1866252,
    "text": "このようにしてreactでリストを作成する。"
  },
  {
    "start": 1866396,
    "end": 1872276,
    "text": "ここに何を入れても、私たち3人のために3回スクリーンにレンダリングされる。"
  },
  {
    "start": 1872428,
    "end": 1874052,
    "text": "今はシンプルに考えよう。"
  },
  {
    "start": 1874196,
    "end": 1878836,
    "text": "それぞれのタイトルを含む段落タグをレンダリングしてみよう。"
  },
  {
    "start": 1878868,
    "end": 1884500,
    "text": "そのために、再び中括弧を付けて、Todoのタイトルを書く。"
  },
  {
    "start": 1884580,
    "end": 1889052,
    "text": "これを保存すると、3つのToDoのタイトルが表示される。"
  },
  {
    "start": 1889236,
    "end": 1896980,
    "text": "さて、このようにreactでリストをレンダリングするたびに、それぞれのリスト項目に一意のキーを与えなければならない。"
  },
  {
    "start": 1897100,
    "end": 1906020,
    "text": "アイテムの順番が変わる可能性がある場合、このキーは重要である。"
  },
  {
    "start": 1906140,
    "end": 1909324,
    "text": "各アイテムを一意に識別するキーが必要です。"
  },
  {
    "start": 1909412,
    "end": 1914028,
    "text": "このidは各エレメントで一意である。"
  },
  {
    "start": 1914204,
    "end": 1923524,
    "text": "データベースにデータを格納する実際のアプリケーションでは、すべてのデータベースがすべての行に対して一意なIDを持つため、一意なアイデアも持っている。"
  },
  {
    "start": 1923612,
    "end": 1929996,
    "text": "というアイデアは、通常、リストのマップ呼び出しのキーとして使いたいものだ。"
  },
  {
    "start": 1930148,
    "end": 1932836,
    "text": "ここではTodo IDを渡す。"
  },
  {
    "start": 1933028,
    "end": 1938436,
    "text": "ちなみに、これを追加しないと、リアクトもコンソールで文句を言うことになる。"
  },
  {
    "start": 1938508,
    "end": 1941860,
    "text": "リスト内の各子供は一意なキーを持つべきであるので、これを無視してはならない。"
  },
  {
    "start": 1941980,
    "end": 1944508,
    "text": "さて、このスタイルも少し変えてみよう。"
  },
  {
    "start": 1944644,
    "end": 1951708,
    "text": "各段落タグに直接クラス名を追加し、テキストLGでテキストを少し大きくすることができる。"
  },
  {
    "start": 1951884,
    "end": 1955140,
    "text": "そして、これらの要素の間に縦の間隔を加えたい。"
  },
  {
    "start": 1955260,
    "end": 1960040,
    "text": "リストを囲んでいるこの内側のdivの中に入る。"
  },
  {
    "start": 1960900,
    "end": 1964532,
    "text": "ここで、クラス空間yを2つ追加する。"
  },
  {
    "start": 1964676,
    "end": 1970680,
    "text": "また、これらのクラス名の上にカーソルを置くと、どのCSS値が適用されるかをいつでも見ることができます。"
  },
  {
    "start": 1971440,
    "end": 1989784,
    "text": "外側のdivにMaxwlGとMX Autoというクラス名を追加して、この外側のラッパーに最大幅を与え、画面の端まで行かないように画面の中央に配置します。"
  },
  {
    "start": 1989952,
    "end": 1990704,
    "text": "クールだ。"
  },
  {
    "start": 1990872,
    "end": 1999876,
    "text": "また、このJの式の下にforループを置くことができないので、このようなことができないことも指摘しておく。"
  },
  {
    "start": 1999988,
    "end": 2010572,
    "text": "なぜなら、forループは式ではなく、何かを返すわけでもないし、forループからUI要素を返すこともできないからだ。"
  },
  {
    "start": 2010636,
    "end": 2013628,
    "text": "そのブロックから返されたものがすべて返される。"
  },
  {
    "start": 2013724,
    "end": 2016532,
    "text": "これが最終的にUIに落とし込んだものだ。"
  },
  {
    "start": 2016676,
    "end": 2018756,
    "text": "forループではできない。"
  },
  {
    "start": 2018868,
    "end": 2024520,
    "text": "ここまでのreturn文の上にforループを置くことはできるが、return文の中には置けない。"
  },
  {
    "start": 2024910,
    "end": 2030830,
    "text": "さて、次はリスト・アイテムを実際のTo Doリスト・アイテムのように見せるために、さらにスタイリングを追加したい。"
  },
  {
    "start": 2030910,
    "end": 2034782,
    "text": "その過程で、初めて独自のコンポーネントを作ることになる。"
  },
  {
    "start": 2034926,
    "end": 2044342,
    "text": "前にも触れたように、コンポーネントを使えば、カプセル化された再利用可能なUIのパーツを作ることができ、独自のロジックを含むこともできる。"
  },
  {
    "start": 2044486,
    "end": 2049366,
    "text": "こうしてコードを整理し、UIの一部を再利用可能にすることができる。"
  },
  {
    "start": 2049478,
    "end": 2057474,
    "text": "例えば、このアプリのページだけでなく、別のページにもTo Doリストを表示したい場合、別のコンポーネントに入れることができる。"
  },
  {
    "start": 2057522,
    "end": 2061322,
    "text": "これらの異なるページでまったく同じコードを繰り返す必要はない。"
  },
  {
    "start": 2061466,
    "end": 2065194,
    "text": "最近のリアクトでは、コンポーネントを関数として書く。"
  },
  {
    "start": 2065362,
    "end": 2073362,
    "text": "昔は授業として書いていたが、それは恐竜がまだ生きていて、ファラオがまだいた昔の話だ。"
  },
  {
    "start": 2073506,
    "end": 2076194,
    "text": "最近では、コンポーネントは関数として書く。"
  },
  {
    "start": 2076322,
    "end": 2077330,
    "text": "よし、やろう。"
  },
  {
    "start": 2077370,
    "end": 2080910,
    "text": "ここで、Todo項目用に別のコンポーネントを作ってみよう。"
  },
  {
    "start": 2081380,
    "end": 2097828,
    "text": "もう一度エクスプローラーを開き、これをsr zeroに入れ、componentsというフォルダを作り、この中にto do item、to do a list item、to do rowなど、好きな名前を付けたい。"
  },
  {
    "start": 2097924,
    "end": 2102252,
    "text": "これはコンポーネントなので、今回はTSXファイルでなければならない。"
  },
  {
    "start": 2102316,
    "end": 2102920,
    "text": "そうだろう？"
  },
  {
    "start": 2103540,
    "end": 2109926,
    "text": "ここでは、todo itemという同じ名前のデフォルト関数をエクスポートしている。"
  },
  {
    "start": 2110078,
    "end": 2117134,
    "text": "コンポーネントの命名規則はパスカル・ケース、つまりキャメルケースだが、最初の文字は大文字である。"
  },
  {
    "start": 2117262,
    "end": 2123334,
    "text": "通常のHTMLタグが小文字で始まるのに対し、コンポーネントは大文字で始まる。"
  },
  {
    "start": 2123422,
    "end": 2126638,
    "text": "ファイル名の命名規則に従う必要はない。"
  },
  {
    "start": 2126694,
    "end": 2138890,
    "text": "小文字のtodo itemのように別の名前をつけることもできるが、私はファイルとデフォルトのエクスポート・コンポーネントに同じ名前（この場合はtodo item）をつけたい。"
  },
  {
    "start": 2139050,
    "end": 2140482,
    "text": "これは関数だ。"
  },
  {
    "start": 2140626,
    "end": 2143670,
    "text": "括弧と中括弧を追加する。"
  },
  {
    "start": 2144090,
    "end": 2151110,
    "text": "コンポーネントではUIの一部を返さなければならないので、括弧を返そう。"
  },
  {
    "start": 2152170,
    "end": 2167060,
    "text": "括弧があるのは、リターン・コードを新しい行に入れるためだけで、とりあえず、画面に表示できるように、todo項目とだけ書かれたHTMLのdivを返しておこう。"
  },
  {
    "start": 2167480,
    "end": 2178096,
    "text": "そして、アプリのTSXファイルに戻り、この段落タグの代わりに、このようなTodo項目をレンダリングする。"
  },
  {
    "start": 2178208,
    "end": 2188140,
    "text": "HTMLタグをどのようにレンダリングするかというと、大文字の頭文字で始まり、コンポーネントの名前、そして自己閉じタグを与えるだけである。"
  },
  {
    "start": 2188480,
    "end": 2196232,
    "text": "これを保存すると、Todoアイテムのdivが画面上に3回表示されるはずです。"
  },
  {
    "start": 2196376,
    "end": 2199976,
    "text": "もちろん、Todo項目を3回もハードコードするようなことはしたくない。"
  },
  {
    "start": 2200048,
    "end": 2202792,
    "text": "各Todoアイテムのデータをレンダリングしたい。"
  },
  {
    "start": 2202936,
    "end": 2208060,
    "text": "Todoタイプスクリプト・オブジェクトをこのコンポーネントに取り込むには？"
  },
  {
    "start": 2208440,
    "end": 2211660,
    "text": "そのために、このコンポーネントはプロップを受け入れなければならない。"
  },
  {
    "start": 2212360,
    "end": 2216126,
    "text": "プロップスは、リアクト・コンポーネントに対する関数の引数にすぎない。"
  },
  {
    "start": 2216248,
    "end": 2224098,
    "text": "さて、バニラJavaScriptというワイルド・ウェストでは、型なしでこれらのプロップを宣言し、それを渡すことができる。"
  },
  {
    "start": 2224234,
    "end": 2228178,
    "text": "タイプスクリプトでは、小道具の型を用意しなければならない。"
  },
  {
    "start": 2228274,
    "end": 2230042,
    "text": "ここでもインターフェイスを使う。"
  },
  {
    "start": 2230146,
    "end": 2237790,
    "text": "別のファイルにすることもできるが、整理するためには、それを使うコンポーネントと同じファイルにするのが理にかなっている。"
  },
  {
    "start": 2238970,
    "end": 2241426,
    "text": "このインターフェイスの名前はあなた次第だ。"
  },
  {
    "start": 2241618,
    "end": 2246950,
    "text": "私は通常、それをコンポーネントの名前と呼び、それにプロップを付加する。"
  },
  {
    "start": 2247290,
    "end": 2248430,
    "text": "中括弧。"
  },
  {
    "start": 2248930,
    "end": 2252590,
    "text": "ここでは、このコンポーネントがどのような引数を受け付けるかを宣言する。"
  },
  {
    "start": 2253570,
    "end": 2259950,
    "text": "私たちは、\"types \"フォルダからインポートしたTodoアイテムのひとつを受け入れたいと思った。"
  },
  {
    "start": 2260490,
    "end": 2272320,
    "text": "そして、この括弧の中にあるpropsという変数を通過して、これはtodo item propsという型であると言うことができる。"
  },
  {
    "start": 2273580,
    "end": 2284400,
    "text": "このエントリーのオートコンプリートのトリガーをコントロール・スペースで保存すると、引数としてtodoが指定される。"
  },
  {
    "start": 2284820,
    "end": 2289280,
    "text": "これに、このマップ呼び出しのtodo変数を渡すことができる。"
  },
  {
    "start": 2289580,
    "end": 2293386,
    "text": "これで、このデータをTodoアイテム・コンポーネントで使うことができる。"
  },
  {
    "start": 2293548,
    "end": 2296670,
    "text": "私たちができることは、これらの小道具を再構築することだ。"
  },
  {
    "start": 2296750,
    "end": 2302170,
    "text": "この変数名を削除し、代わりに中括弧を追加する。"
  },
  {
    "start": 2302870,
    "end": 2308574,
    "text": "ここにあるのは、小道具の一部だからだ。"
  },
  {
    "start": 2308742,
    "end": 2318690,
    "text": "これで以前と同じように、Todoアイテムの代わりに中かっこをレンダリングして、Todoタイトルを画面に表示することができる。"
  },
  {
    "start": 2319080,
    "end": 2322768,
    "text": "これが、typescriptを使ったreactでのpropsの動作だ。"
  },
  {
    "start": 2322864,
    "end": 2323968,
    "text": "シンプルだろ？"
  },
  {
    "start": 2324064,
    "end": 2327592,
    "text": "もう少し実際のTodo項目のようなスタイルにしたい。"
  },
  {
    "start": 2327616,
    "end": 2334584,
    "text": "このTodoのタイトルを削除して、代わりにここにラベルを貼ってみよう。"
  },
  {
    "start": 2334752,
    "end": 2345846,
    "text": "ラベルを使うのは、ここにチェックボックスを入れたいからで、ボックスを直接クリックしなくても、この項目の他のどこかをクリックしても、このチェックボックスをチェックしたいからだ。"
  },
  {
    "start": 2345968,
    "end": 2348706,
    "text": "これがHTMLラベルの成果である。"
  },
  {
    "start": 2348818,
    "end": 2350626,
    "text": "これは反応に限ったことではない。"
  },
  {
    "start": 2350738,
    "end": 2352910,
    "text": "これはHTMLそのものだ。"
  },
  {
    "start": 2353730,
    "end": 2362630,
    "text": "さて、ここにチェックボックスを置きたいのだが、これはHTMLのinput要素で行う。"
  },
  {
    "start": 2364330,
    "end": 2370178,
    "text": "この入力のタイプをチェックボックスに設定し、これらは基本的に小道具である。"
  },
  {
    "start": 2370274,
    "end": 2374254,
    "text": "同じように、Todoアイテムも小道具を受け付ける。"
  },
  {
    "start": 2374362,
    "end": 2378650,
    "text": "これらは、さまざまなコンポーネントやHTML要素に対する引数である。"
  },
  {
    "start": 2379550,
    "end": 2382570,
    "text": "これを保存すると、3つのチェックボックスが表示される。"
  },
  {
    "start": 2383150,
    "end": 2389462,
    "text": "また、もう少し大きくしてみよう。そのためにスケールという追い風クラスがある。"
  },
  {
    "start": 2389606,
    "end": 2395690,
    "text": "もう少し大きくするために、これを125％に拡大したい。"
  },
  {
    "start": 2396270,
    "end": 2397526,
    "text": "オーケー、クールだ。"
  },
  {
    "start": 2397718,
    "end": 2405360,
    "text": "入力の下にあるラベルの中にも、タイトルのテキストをスパニッシュで表示する。"
  },
  {
    "start": 2406100,
    "end": 2412320,
    "text": "ここではTodoのタイトルをレンダリングしている。"
  },
  {
    "start": 2412660,
    "end": 2414020,
    "text": "さて、ここでクールなことがある。"
  },
  {
    "start": 2414100,
    "end": 2418668,
    "text": "これらのクラス名を引用符の代わりにハードコードする必要はない。"
  },
  {
    "start": 2418844,
    "end": 2422212,
    "text": "ここに中括弧で式を書くこともできる。"
  },
  {
    "start": 2422396,
    "end": 2425044,
    "text": "ここにもJavaScriptのロジックを入れることができる。"
  },
  {
    "start": 2425132,
    "end": 2427396,
    "text": "例えば、三項演算子を使うことができる。"
  },
  {
    "start": 2427468,
    "end": 2438998,
    "text": "もしTodo completedがtrueで、クエスチョンマーク付きの三項演算子を使うなら、いくつかのクラスを返したい。"
  },
  {
    "start": 2439174,
    "end": 2443806,
    "text": "コロンでなければ、これらのクラスは適用したくない。"
  },
  {
    "start": 2443878,
    "end": 2452086,
    "text": "ここでは、このクラス名をストリンジェントに保ち、completedがtrueの場合にのみ適用されるスタイリングだけを追加する。"
  },
  {
    "start": 2452238,
    "end": 2453830,
    "text": "completedがtrueの場合。"
  },
  {
    "start": 2453950,
    "end": 2457432,
    "text": "このテキストを構造化したい。"
  },
  {
    "start": 2457576,
    "end": 2465820,
    "text": "テールウィンド・クラスにラインスルーを追加し、テキストをグレー400でグレーにしたい。"
  },
  {
    "start": 2466400,
    "end": 2471620,
    "text": "ご覧のように、tailwindエクステンションをインストールしたため、カラープレビューまで表示される。"
  },
  {
    "start": 2471960,
    "end": 2474768,
    "text": "これで、この条件クラスができた。"
  },
  {
    "start": 2474864,
    "end": 2483856,
    "text": "これを実際に見てみるために、配列の中にあるダミー・データに入って、これらの要素の完成した値をtrueに設定してみよう。"
  },
  {
    "start": 2484008,
    "end": 2486448,
    "text": "今はこのように違うスタイルで描かれている。"
  },
  {
    "start": 2486544,
    "end": 2487728,
    "text": "クールだろ？"
  },
  {
    "start": 2487904,
    "end": 2491984,
    "text": "また、ラベル自体にクラス名をつけて、少しスタイルを整えなければならない。"
  },
  {
    "start": 2492032,
    "end": 2494220,
    "text": "これをフレックスボックスのリフレックスにする。"
  },
  {
    "start": 2495080,
    "end": 2498152,
    "text": "アイテムセンターでアイテムを中央に配置したい。"
  },
  {
    "start": 2498296,
    "end": 2499848,
    "text": "ギャップは2。"
  },
  {
    "start": 2499944,
    "end": 2503060,
    "text": "これらのクラス名のほとんどは、自分で説明できるものだと思う。"
  },
  {
    "start": 2503960,
    "end": 2506300,
    "text": "ボーダーを加えたい。"
  },
  {
    "start": 2508080,
    "end": 2512620,
    "text": "このボーダーを丸みを帯びたものにしたい。"
  },
  {
    "start": 2513950,
    "end": 2519090,
    "text": "ボーダーがある場合、通常はp2でパディングを追加する。"
  },
  {
    "start": 2519510,
    "end": 2524942,
    "text": "ボーダーの色をボーダーグレー400に変更したい。"
  },
  {
    "start": 2525126,
    "end": 2527970,
    "text": "もちろん、好きなようにスタイリングできる。"
  },
  {
    "start": 2528310,
    "end": 2531810,
    "text": "各要素の背景色を白に設定したい。"
  },
  {
    "start": 2532350,
    "end": 2533570,
    "text": "もうひとつ。"
  },
  {
    "start": 2533910,
    "end": 2535886,
    "text": "このホバー修飾子を使う。"
  },
  {
    "start": 2536038,
    "end": 2544800,
    "text": "この方法で、マウスでこの要素にカーソルを合わせたときだけクラスを適用することができます。"
  },
  {
    "start": 2546380,
    "end": 2551604,
    "text": "これらのクラスをすべて入力すると、エレメントはこのようになる。"
  },
  {
    "start": 2551772,
    "end": 2555000,
    "text": "カーソルを合わせると、このように色が変わります。"
  },
  {
    "start": 2555380,
    "end": 2567164,
    "text": "ラベルを使うことの利点は、この項目のどこをクリックしてもチェックボックスをチェックできることだ。"
  },
  {
    "start": 2567292,
    "end": 2574180,
    "text": "Reactの宣言的アプローチのおかげで、この最後の要素のスタイルを明示的に変更する必要はなかった。"
  },
  {
    "start": 2574260,
    "end": 2580748,
    "text": "コードに指示を与えて、テキストの背景色をこの色に変えろ、などと言う必要はなかった。"
  },
  {
    "start": 2580884,
    "end": 2584508,
    "text": "私たちは、自分たちのアイテムをどのように見せたいかを宣言するだけだ。"
  },
  {
    "start": 2584644,
    "end": 2586900,
    "text": "渡すデータによって異なる。"
  },
  {
    "start": 2586980,
    "end": 2594906,
    "text": "渡すデータが変更されると、画面は自動的に新しいUI状態で再レンダリングされる。"
  },
  {
    "start": 2595058,
    "end": 2597146,
    "text": "じゃあ、もう少しスタイリングを。"
  },
  {
    "start": 2597218,
    "end": 2600018,
    "text": "アプリのページに追加したい。"
  },
  {
    "start": 2600154,
    "end": 2604230,
    "text": "まず、見出しとリストの間に間隔を空けたい。"
  },
  {
    "start": 2604650,
    "end": 2613898,
    "text": "メイン・タグに行き、このスペースy 5クラスを追加する。"
  },
  {
    "start": 2614074,
    "end": 2619538,
    "text": "次に、このLGの最大幅を持つdivに入る。"
  },
  {
    "start": 2619554,
    "end": 2623270,
    "text": "背景色をBGスレート100に設定したい。"
  },
  {
    "start": 2624170,
    "end": 2628670,
    "text": "ここでも丸みをつけ、5つのパディングを追加したい。"
  },
  {
    "start": 2629530,
    "end": 2631190,
    "text": "今はこんな感じだ。"
  },
  {
    "start": 2631490,
    "end": 2632550,
    "text": "本当にクールだ。"
  },
  {
    "start": 2633570,
    "end": 2644816,
    "text": "というのも、今、これらの要素のひとつをチェックすると、チェックボックスが変わっても、もちろん配列のデータは変更されないからです。"
  },
  {
    "start": 2644978,
    "end": 2651360,
    "text": "ページをリフレッシュすると、すべてのチェックボックスは再びチェックされなくなるので、どこにも状態を保存しない。"
  },
  {
    "start": 2651700,
    "end": 2658772,
    "text": "Reactは、この一方向のデータフローという考え方に従っている。"
  },
  {
    "start": 2658836,
    "end": 2664884,
    "text": "この一方向性とは、データが下方にしか流れないことを理解することが重要だ。"
  },
  {
    "start": 2665012,
    "end": 2679654,
    "text": "先ほど見たように、Todoのステートを別のコンポーネントであるTodoアイテムに渡したからだ。"
  },
  {
    "start": 2679742,
    "end": 2693414,
    "text": "配列のブール値を変更したときのように、このデータが変更されると、このデータを使用しているコンポーネント・ツリーのこの部分は、新しい状態を表すためにreactによって再レンダリングされる。"
  },
  {
    "start": 2693582,
    "end": 2696558,
    "text": "ここのTodo項目のスタイルが変わった。"
  },
  {
    "start": 2696654,
    "end": 2704026,
    "text": "つまり、コンポーネント・ツリーの各部分の状態を、これらすべての異なるコンポーネントの親に保持するのだ。"
  },
  {
    "start": 2704138,
    "end": 2708154,
    "text": "一番上がアプリのページだとしよう。"
  },
  {
    "start": 2708322,
    "end": 2714930,
    "text": "これは私たちのto do項目であり、他のコンポーネント、例えばstatistics要素にあるとしよう。"
  },
  {
    "start": 2715050,
    "end": 2716978,
    "text": "やることリストも必要だ。"
  },
  {
    "start": 2717074,
    "end": 2726474,
    "text": "そして、ページそのものである親コンポーネントにto doリストを保持し、この状態を必要とする子コンポーネントにpropsとして渡す。"
  },
  {
    "start": 2726602,
    "end": 2738120,
    "text": "例えば、このTodoアイテムの状態をTodoアイテム・コンポーネントに入れることはできない。なぜなら、親コンポーネントからアクセスできないし、他の子コンポーネントからもアクセスできないからだ。"
  },
  {
    "start": 2738200,
    "end": 2745848,
    "text": "それは共通の親でなければならず、通常は州が必要とする最も低い共通の親に置く。"
  },
  {
    "start": 2745984,
    "end": 2751912,
    "text": "もし、これがまだ分かりにくいとしても、心配しないでほしい。"
  },
  {
    "start": 2752056,
    "end": 2756056,
    "text": "もちろん、子コンポーネントから状態を更新したい場合もある。"
  },
  {
    "start": 2756128,
    "end": 2764054,
    "text": "例えば、この子コンポーネントで発生するTo Doリストの項目をチェックする場合、To Doリスト自体の状態を変更しなければならない。"
  },
  {
    "start": 2764182,
    "end": 2766726,
    "text": "コールバック関数でこれを行う。"
  },
  {
    "start": 2766838,
    "end": 2771050,
    "text": "このようなコールバック関数をプロジェクトに実装する方法を見てみよう。"
  },
  {
    "start": 2771390,
    "end": 2775982,
    "text": "Todoアイテム・コンポーネント・ファイルに新しいプロップを追加します。"
  },
  {
    "start": 2776126,
    "end": 2779398,
    "text": "繰り返しになるが、この小道具の名前は個人の好みによる。"
  },
  {
    "start": 2779574,
    "end": 2791950,
    "text": "oncompletedchangeコロンと呼ぶことにする。この型は関数で、このように括弧、右矢印、戻り値の型としてvoidを宣言する。"
  },
  {
    "start": 2792070,
    "end": 2793770,
    "text": "何も返さない。"
  },
  {
    "start": 2794150,
    "end": 2796630,
    "text": "ただし、この関数は引数を取る。"
  },
  {
    "start": 2796750,
    "end": 2801774,
    "text": "ToDoリストの項目をチェックするときに必要な情報が得られる。"
  },
  {
    "start": 2801902,
    "end": 2807262,
    "text": "項目をチェックするとき、状態を変更するために親に渡さなければならない情報は何ですか？"
  },
  {
    "start": 2807446,
    "end": 2816004,
    "text": "さて、どの項目をチェックしたかを知る必要があるが、これはアイデアによって把握できる。"
  },
  {
    "start": 2816172,
    "end": 2825404,
    "text": "iDは数値、completedはブール値である。"
  },
  {
    "start": 2825532,
    "end": 2832560,
    "text": "状態を変更するために必要なのは、Todoアイテムのタイトルではなく、アイデアと新しい完了値だけです。"
  },
  {
    "start": 2833220,
    "end": 2838520,
    "text": "そして、この新しい支柱を構造変更する。"
  },
  {
    "start": 2839380,
    "end": 2841620,
    "text": "次にチェックボックスに入る。"
  },
  {
    "start": 2841660,
    "end": 2846174,
    "text": "これを複数行に分けて、新しい小道具を追加してみよう。"
  },
  {
    "start": 2846302,
    "end": 2857718,
    "text": "まず最初に、このチェックボックスはTodoアイテムが実際に完了した場合にのみチェックされるべきものであることをお伝えしたい。"
  },
  {
    "start": 2857854,
    "end": 2871210,
    "text": "チェックボックスがデフォルトではチェックされていないにもかかわらず、チェックされた値を明示的に式に設定することでこれを修正することができる。"
  },
  {
    "start": 2871600,
    "end": 2876032,
    "text": "これでチェックされ、チェックされた状態を変更することはできなくなった。"
  },
  {
    "start": 2876176,
    "end": 2880540,
    "text": "コールバックを実装する。"
  },
  {
    "start": 2880920,
    "end": 2887968,
    "text": "そのために、ここでそのようなアイテムをクリックしたときに実行されるonchangeプロパティを使います。"
  },
  {
    "start": 2887984,
    "end": 2912642,
    "text": "この引数を受け取るエラー関数にカーソルを合わせると、これがreact changeevent型であることがわかる。"
  },
  {
    "start": 2912706,
    "end": 2914650,
    "text": "私たちはTodoのアイデアをパスする。"
  },
  {
    "start": 2914770,
    "end": 2926040,
    "text": "カンマをクリックし、新しいチェック値がこの年変数year dot target dot checkedの中にある。"
  },
  {
    "start": 2927340,
    "end": 2931228,
    "text": "チェックボックスをクリックするたびに、このコールバックがトリガーされます。"
  },
  {
    "start": 2931324,
    "end": 2933292,
    "text": "このコールバックはどうなるのか？"
  },
  {
    "start": 2933436,
    "end": 2935892,
    "text": "今は何もしていないよね？"
  },
  {
    "start": 2936076,
    "end": 2941320,
    "text": "これはプロップなので、Todoアイテム・コンポーネントに渡す必要があります。"
  },
  {
    "start": 2941980,
    "end": 2944828,
    "text": "変更完了時のコールバックです。"
  },
  {
    "start": 2944964,
    "end": 2947228,
    "text": "ここで、このコールバックを使って何かをすることができる。"
  },
  {
    "start": 2947284,
    "end": 2958764,
    "text": "このようにエラー関数として渡すこともできるが、組織としては、エラー関数を別の関数として宣言したい場合が多い。"
  },
  {
    "start": 2958932,
    "end": 2964116,
    "text": "ここでは、setという関数を置いて完了させることにしよう。"
  },
  {
    "start": 2964268,
    "end": 2970892,
    "text": "ここでも名前は自由で、コールバックと同じ引数を取る必要がある。"
  },
  {
    "start": 2971036,
    "end": 2984664,
    "text": "これをコピーして、中カッコで囲んで、この関数名をprop値として渡すことができる。"
  },
  {
    "start": 2984792,
    "end": 2989200,
    "text": "括弧をつけずに、ただ名前を渡すだけだ。"
  },
  {
    "start": 2989360,
    "end": 2996256,
    "text": "このように関数リファレンスを渡すと、このコールバックがトリガーされるたびにzを呼び出して完了させる。"
  },
  {
    "start": 2996448,
    "end": 2999616,
    "text": "今はまだ更新できる状態ではない。"
  },
  {
    "start": 2999688,
    "end": 3002216,
    "text": "これについては次のセクションで説明する。"
  },
  {
    "start": 3002288,
    "end": 3008454,
    "text": "とりあえず、アラートメッセージを表示して、実際にこのコールバックを受け取ったことを確認しよう。"
  },
  {
    "start": 3008582,
    "end": 3017690,
    "text": "alertを呼び出すとき、バックテキスト文字列をここに渡す。"
  },
  {
    "start": 3018150,
    "end": 3029090,
    "text": "ドル記号の中括弧でTodoを書きましょう アイデアはドル記号の中括弧になりました。"
  },
  {
    "start": 3030070,
    "end": 3040554,
    "text": "completedがtrueならis now completedと表示され、そうでなければnot completedと表示される。"
  },
  {
    "start": 3040722,
    "end": 3050034,
    "text": "この文字列をタイプアウトしたところで、よく注意して見ていれば、ここにキーをセットし忘れていることに気づいたかもしれない。"
  },
  {
    "start": 3050122,
    "end": 3052338,
    "text": "それに気づいたなら、上出来だ。"
  },
  {
    "start": 3052474,
    "end": 3055850,
    "text": "リストをレンダリングする際には、必ずキーが必要になる。"
  },
  {
    "start": 3055970,
    "end": 3058710,
    "text": "ここでtodo IDを渡す。"
  },
  {
    "start": 3059520,
    "end": 3062072,
    "text": "では、コールバックが機能するか見てみよう。"
  },
  {
    "start": 3062136,
    "end": 3072040,
    "text": "すべてを保存し、ページを開き、アイテムをクリックすると、id1が完了した新しい状態が表示されます。"
  },
  {
    "start": 3072160,
    "end": 3079100,
    "text": "実際に状態を変化させるわけではないので、画面にはまだ表示されていないが、これが機能していることはすでに確認できる。"
  },
  {
    "start": 3079800,
    "end": 3087952,
    "text": "次に、リアクト・ステートについて学び、これらのTodo項目をクリックしたときに画面に表示される内容を実際に変更する方法を学ぶ。"
  },
  {
    "start": 3088096,
    "end": 3092016,
    "text": "現在、すべてのTodoはこの配列にハードコードされている。"
  },
  {
    "start": 3092168,
    "end": 3097608,
    "text": "ToDoをクリックしたときに、状態を変更できるようにするにはどうすればいいのだろう？"
  },
  {
    "start": 3097704,
    "end": 3101976,
    "text": "そのためにはリアクト・ステートが必要で、次のように作成した。"
  },
  {
    "start": 3102088,
    "end": 3105280,
    "text": "アプリ・コンポーネントの一番上に行く。"
  },
  {
    "start": 3105400,
    "end": 3111900,
    "text": "関数内部でconstを宣言し、次のように角括弧を2つ作る。"
  },
  {
    "start": 3112400,
    "end": 3120384,
    "text": "ここでは、todosとz todosをこの等号エントリーのようにキャメルケースで書く。"
  },
  {
    "start": 3120432,
    "end": 3125460,
    "text": "これをreactからのインポートであるuse stateに割り当てる。"
  },
  {
    "start": 3125760,
    "end": 3129120,
    "text": "自動的にインポートされなければ、ここで見ることができる。"
  },
  {
    "start": 3129200,
    "end": 3134296,
    "text": "これを手で書き出し、usestateにダミーデータを渡す。"
  },
  {
    "start": 3134488,
    "end": 3140262,
    "text": "そしてusestateから、この配列の中のタプルの中にある2つの値を取得する。"
  },
  {
    "start": 3140446,
    "end": 3155606,
    "text": "これは、ここで渡すダミー・データから自動的に推測されるもので、アプリを開いたときにこのステートが持つ初期値だからだ。"
  },
  {
    "start": 3155718,
    "end": 3160718,
    "text": "ここでデフォルト値を渡さなかった場合、ステートの型は未定義となる。"
  },
  {
    "start": 3160814,
    "end": 3163132,
    "text": "タイプスクリプトはこのタイプを推測することができる。"
  },
  {
    "start": 3163246,
    "end": 3168900,
    "text": "このように角括弧で明示的に設定することもできるが、その必要はない。"
  },
  {
    "start": 3170360,
    "end": 3175848,
    "text": "ここで得られる2番目の値、z todosは、この日付を更新するために使用できる関数である。"
  },
  {
    "start": 3175944,
    "end": 3177392,
    "text": "これについてはまた後で。"
  },
  {
    "start": 3177496,
    "end": 3183576,
    "text": "これらuseで始まる関数はすべて、reactではフックと呼ばれる特別な関数である。"
  },
  {
    "start": 3183688,
    "end": 3189216,
    "text": "フックを使えば、ステートや副作用のようなリアクトの特別な機能を使うことができる。"
  },
  {
    "start": 3189288,
    "end": 3190412,
    "text": "これについては後ほど。"
  },
  {
    "start": 3190536,
    "end": 3194788,
    "text": "このチュートリアルの最後には、独自のカスタムフックも作成します。"
  },
  {
    "start": 3194844,
    "end": 3195836,
    "text": "期待していてほしい。"
  },
  {
    "start": 3195948,
    "end": 3202916,
    "text": "では、このアラートメッセージを表示する代わりに、Todoerをチェックしたり外したりしたときに、ステートを更新したい。"
  },
  {
    "start": 3203068,
    "end": 3209084,
    "text": "zトドス関数を呼び出す。"
  },
  {
    "start": 3209212,
    "end": 3214292,
    "text": "この関数には2つのバージョンがあり、新しい状態をその値で直接渡すこともできる。"
  },
  {
    "start": 3214356,
    "end": 3217724,
    "text": "例えば、Todoオブジェクトの配列を渡すことができる。"
  },
  {
    "start": 3217812,
    "end": 3221028,
    "text": "もうひとつの選択肢は、ここにエラー関数を渡すことだ。"
  },
  {
    "start": 3221164,
    "end": 3225508,
    "text": "ここで括弧をつけると、前のトドを渡される。"
  },
  {
    "start": 3225644,
    "end": 3233996,
    "text": "これは更新前のtodosの状態であり、このarrow関数を使って新しい状態を作ることができる。"
  },
  {
    "start": 3234188,
    "end": 3239560,
    "text": "このエラー関数から返されるものが、トドメの新しい状態になる。"
  },
  {
    "start": 3240060,
    "end": 3241724,
    "text": "ここで何を通過しなければならないのか？"
  },
  {
    "start": 3241812,
    "end": 3247360,
    "text": "さて、ダミーデータと同じように、更新された状態の配列を渡さなければならない。"
  },
  {
    "start": 3247700,
    "end": 3249120,
    "text": "どうすればいいのか？"
  },
  {
    "start": 3249620,
    "end": 3254500,
    "text": "そのためには、古い状態のエントリー・マップを含むprev todosを取得する。"
  },
  {
    "start": 3254540,
    "end": 3263004,
    "text": "この新しいステート・マップは、リアクトの機能的な性質にぴったりなので、リアクトではよく使う関数だ。"
  },
  {
    "start": 3263132,
    "end": 3268964,
    "text": "配列を別の配列動物園に変換して整理する方法だ。"
  },
  {
    "start": 3269052,
    "end": 3272204,
    "text": "これをマップと呼ぶ別の行にしよう。"
  },
  {
    "start": 3272292,
    "end": 3279094,
    "text": "いつものように、配列をマップするとき、この配列の各項目をアロー関数で通過させる。"
  },
  {
    "start": 3279142,
    "end": 3280902,
    "text": "また右矢印にする。"
  },
  {
    "start": 3281046,
    "end": 3282902,
    "text": "この地図呼び出しで何をしたいのか？"
  },
  {
    "start": 3282966,
    "end": 3296078,
    "text": "さて、古い状態を取得し、UIで今クリックしたアイデアを持つ要素を見つけ、この要素を更新して新しい更新完了の状態にしたい。"
  },
  {
    "start": 3296254,
    "end": 3315280,
    "text": "このマップ・アロー関数の中で、もうひとつ括弧のペアを作り、その中に式を入れる。"
  },
  {
    "start": 3315320,
    "end": 3319936,
    "text": "三項演算子を使い、thisの新しい状態を渡す。"
  },
  {
    "start": 3319968,
    "end": 3320496,
    "text": "やることだ。"
  },
  {
    "start": 3320608,
    "end": 3322580,
    "text": "JavaScriptオブジェクトを渡す。"
  },
  {
    "start": 3323680,
    "end": 3330230,
    "text": "私たちは、このマップ・コールから、タイトルとアイデアで既存のto doを広めた。"
  },
  {
    "start": 3330850,
    "end": 3336762,
    "text": "コンマの後に、完了した値をより新しい完了した値に更新したい。"
  },
  {
    "start": 3336946,
    "end": 3339070,
    "text": "この1つのフィールドだけを更新する。"
  },
  {
    "start": 3339370,
    "end": 3343370,
    "text": "もしidが一致しなければ、更新したいオブジェクトではないことになる。"
  },
  {
    "start": 3343450,
    "end": 3347722,
    "text": "これは配列内の他のオブジェクトのひとつで、この場合はコロン。"
  },
  {
    "start": 3347866,
    "end": 3351746,
    "text": "alt todoerを古い状態のままにしておきたいだけなのです。"
  },
  {
    "start": 3351938,
    "end": 3356608,
    "text": "少し複雑に見えるが、これがreactで状態を更新する方法だ。"
  },
  {
    "start": 3356784,
    "end": 3360032,
    "text": "配列を更新しているので、より複雑になっている。"
  },
  {
    "start": 3360176,
    "end": 3363872,
    "text": "もしステートが普通の文字列だったら、もちろんこの方が簡単だ。"
  },
  {
    "start": 3364056,
    "end": 3366912,
    "text": "ここで、この配列を新しい状態にマッピングしなければならない。"
  },
  {
    "start": 3367016,
    "end": 3375860,
    "text": "ダミーのデータをTodosの状態に置き換えることで、実際に更新できるようになるはずだ。"
  },
  {
    "start": 3376160,
    "end": 3382112,
    "text": "試しにアイテムをクリックしてみよう。"
  },
  {
    "start": 3382216,
    "end": 3383216,
    "text": "クールだろ？"
  },
  {
    "start": 3383328,
    "end": 3388224,
    "text": "ここで重要なのは、mapはまったく新しい配列を返すということだ。"
  },
  {
    "start": 3388352,
    "end": 3396056,
    "text": "カーソルを合わせると、各要素に対して定義されたコールバック関数が呼び出され、その結果を含む配列が返されるのがわかる。"
  },
  {
    "start": 3396208,
    "end": 3401920,
    "text": "mapは元の配列を変更せず、まったく新しい配列を返す。"
  },
  {
    "start": 3402000,
    "end": 3410468,
    "text": "というのも、リアクトが画面を更新しなければならないことに気づく方法は、ステートの参照を比較することだからだ。"
  },
  {
    "start": 3410624,
    "end": 3419780,
    "text": "このTodoステートの配列を新しいものに置き換えたことに気づくと、新しい配列は古い配列とは異なる新しい参照を持つことになる。"
  },
  {
    "start": 3419860,
    "end": 3424220,
    "text": "こうすることで、リアクトは新しいデータで画面を再レンダリングしなければならないことを知る。"
  },
  {
    "start": 3424340,
    "end": 3430084,
    "text": "そのため、既存の配列を直接変更することはできない。"
  },
  {
    "start": 3430212,
    "end": 3432388,
    "text": "ちょっと試してみよう。"
  },
  {
    "start": 3432564,
    "end": 3441086,
    "text": "このマップ・コールをコピーするが、z個のトドを削除し、ここでは直接配列を推測するように修正する。"
  },
  {
    "start": 3441238,
    "end": 3444822,
    "text": "これで、何かをクリックしても状態は変わらない。"
  },
  {
    "start": 3444966,
    "end": 3445462,
    "text": "なぜですか？"
  },
  {
    "start": 3445566,
    "end": 3450998,
    "text": "というのも、todosステートの中の配列は、以前と同じ参照を持っているからだ。"
  },
  {
    "start": 3451094,
    "end": 3454342,
    "text": "同じ配列であることに変わりはない。"
  },
  {
    "start": 3454446,
    "end": 3457262,
    "text": "リアクションは画面を更新しなければならないことを知らない。"
  },
  {
    "start": 3457366,
    "end": 3460366,
    "text": "私たちは常に、このステートセットアップを介してこれを行う。"
  },
  {
    "start": 3460518,
    "end": 3464286,
    "text": "もちろん、デフォルトではこの状態はメモリーにのみ保存される。"
  },
  {
    "start": 3464358,
    "end": 3470588,
    "text": "これらの値をチェックしてページを更新すると、デフォルトの状態に戻ります。"
  },
  {
    "start": 3470724,
    "end": 3473760,
    "text": "後ほど、これらの値を永続させる方法を学ぶ。"
  },
  {
    "start": 3474060,
    "end": 3478340,
    "text": "とりあえず、デフォルトのfalseに戻しておこう。"
  },
  {
    "start": 3478420,
    "end": 3482840,
    "text": "ページを更新すると、デフォルトではすべての項目のチェックが外れています。"
  },
  {
    "start": 3483380,
    "end": 3487804,
    "text": "次に、To Doリストに新しいTo Doを追加するフォームを追加したい。"
  },
  {
    "start": 3487972,
    "end": 3492748,
    "text": "ToDoリストに新しいToDoを追加するフォームをここに置きたい。"
  },
  {
    "start": 3492804,
    "end": 3498524,
    "text": "これで、このdivのすぐ上にあるTSXファイルに、これを直接入れることができる。"
  },
  {
    "start": 3498612,
    "end": 3508948,
    "text": "特に、この入力フォームは独自のステートといくつかのロジックを持つことになる。"
  },
  {
    "start": 3509044,
    "end": 3513132,
    "text": "これを別のコンポーネントに抽出することは、整理整頓にとても良い。"
  },
  {
    "start": 3513316,
    "end": 3522040,
    "text": "TodoフォームTSXを追加」という新しいファイルをコンポーネント・フォルダーに追加しましょう。"
  },
  {
    "start": 3523090,
    "end": 3529730,
    "text": "ここでも、uiを返す同じ名前のデフォルト関数をエクスポートする。"
  },
  {
    "start": 3529890,
    "end": 3534082,
    "text": "ここにリターンブロックを追加する。"
  },
  {
    "start": 3534106,
    "end": 3545990,
    "text": "HTMLフォームに、入力フィールドの開始角括弧入力の自己終了タグを挿入して返したい。"
  },
  {
    "start": 3547330,
    "end": 3550670,
    "text": "とりあえずこれを保存してレイアウトに入れよう。"
  },
  {
    "start": 3551680,
    "end": 3555060,
    "text": "リストを包んでいるこのdivの上にある。"
  },
  {
    "start": 3555600,
    "end": 3565580,
    "text": "新しいTodo追加フォームコンポーネントを置いてみましょう。tailwindを使っているので、デフォルトではまったくスタイルがありません。"
  },
  {
    "start": 3565960,
    "end": 3568512,
    "text": "ここにも間隔を空けよう。"
  },
  {
    "start": 3568656,
    "end": 3574780,
    "text": "上のdivに別のクラス空間yを6つ渡す。"
  },
  {
    "start": 3575120,
    "end": 3576860,
    "text": "これで少し間隔が空いた。"
  },
  {
    "start": 3577330,
    "end": 3588830,
    "text": "まだ何も入力していないときに表示されるテキストをプレースホルダーとして入力フィールドに追加できるように、Todo追加フォームコンポーネントのスタイルを完成させましょう。"
  },
  {
    "start": 3589530,
    "end": 3591510,
    "text": "何をすべきか。"
  },
  {
    "start": 3592450,
    "end": 3593550,
    "text": "あれだ。"
  },
  {
    "start": 3594290,
    "end": 3598390,
    "text": "この入力を追い風クラスでスタイル化することもできる。"
  },
  {
    "start": 3598810,
    "end": 3603028,
    "text": "左側だけを丸くしたい。"
  },
  {
    "start": 3603154,
    "end": 3609560,
    "text": "私たちは丸みを帯びたSMDを使っている。"
  },
  {
    "start": 3609720,
    "end": 3618312,
    "text": "左だけ角丸にしたいのは、右側にボタンを付けたいので、右の角は丸くしたくないからです。"
  },
  {
    "start": 3618496,
    "end": 3629660,
    "text": "次に、フォーム自体をフレックスボックスにして、入力フィールドにgrowクラスを追加し、利用可能な幅いっぱいになるようにします。"
  },
  {
    "start": 3630410,
    "end": 3632670,
    "text": "そして、これにボーダーをつける。"
  },
  {
    "start": 3634210,
    "end": 3641670,
    "text": "ボーダーの色を再びグレー400に変え、パディングを2つ追加する。"
  },
  {
    "start": 3642010,
    "end": 3644230,
    "text": "これでもう、かなり良くなったように見える。"
  },
  {
    "start": 3645170,
    "end": 3656602,
    "text": "その隣で申し上げたように、まだフォームの中ですが、inputタグの下にHTMLボタンを置き、テキストにはadditiveと書きます。"
  },
  {
    "start": 3656616,
    "end": 3664534,
    "text": "ここはフォームの中なので、このボタンのタイプをsubmitに設定する。"
  },
  {
    "start": 3664702,
    "end": 3671438,
    "text": "このボタンをクリックするとフォームが送信される。"
  },
  {
    "start": 3671614,
    "end": 3674290,
    "text": "となると、もちろんこのボタンにスタイルを付ける必要がある。"
  },
  {
    "start": 3674630,
    "end": 3678730,
    "text": "このボタンの幅を16に固定したい。"
  },
  {
    "start": 3680750,
    "end": 3688130,
    "text": "丸みを帯びた形にしたいのですが、今回は右側だけエムデンナのeはendを意味します。"
  },
  {
    "start": 3690550,
    "end": 3699410,
    "text": "背景色をbg slate 900に設定したいのですが、黒とまではいきません。"
  },
  {
    "start": 3700070,
    "end": 3703790,
    "text": "そして、このボタンにカーソルを合わせたときの背景色を変えたい。"
  },
  {
    "start": 3703830,
    "end": 3713900,
    "text": "このボタンにカーソルを合わせたら、背景色をbg slate 800に設定したい。"
  },
  {
    "start": 3714240,
    "end": 3716900,
    "text": "これで光のホバーエフェクトができた。"
  },
  {
    "start": 3717360,
    "end": 3722152,
    "text": "reactの入力フィールドはデフォルトで内部状態を持つ。"
  },
  {
    "start": 3722296,
    "end": 3728936,
    "text": "このため、このコンポーネントでは、入力のための使用状態がないにもかかわらず、ここに何かを入力することができる。"
  },
  {
    "start": 3729008,
    "end": 3734472,
    "text": "このようなことが可能なのは、これらの入力フィールドがDoMによって処理される内部状態を持っているからである。"
  },
  {
    "start": 3734536,
    "end": 3739248,
    "text": "基本的にはHTMLツリーそのものであり、reactでは2つのオプションがある。"
  },
  {
    "start": 3739304,
    "end": 3744282,
    "text": "このままにしておいて、必要なときにここから価値を引き出すこともできる。"
  },
  {
    "start": 3744426,
    "end": 3749042,
    "text": "あるいは、このコントロールされていないフィールドをコントロールされたフィールドに変えることもできる。"
  },
  {
    "start": 3749186,
    "end": 3759266,
    "text": "制御されるとは、先ほどTodo項目で行ったように、入力フィールドの値を直接渡して、コールバックで更新することです。"
  },
  {
    "start": 3759378,
    "end": 3766226,
    "text": "これらの制御された入力フィールドは、この入力で何をするかについて、ダジャレではなく、より多くの制御を与える。"
  },
  {
    "start": 3766338,
    "end": 3772398,
    "text": "例えば、新しいTodoを追加した後、コントロールされていない入力で入力フィールドを空っぽにしたい。"
  },
  {
    "start": 3772454,
    "end": 3776510,
    "text": "これは、状態に裏打ちされた制御入力では難しい。"
  },
  {
    "start": 3776630,
    "end": 3779614,
    "text": "状態を更新すればいいだけだから簡単だ。"
  },
  {
    "start": 3779782,
    "end": 3785238,
    "text": "入力フィールドをコントロールされた入力フィールドにしてみよう。"
  },
  {
    "start": 3785374,
    "end": 3789918,
    "text": "そのために、Todo追加フォームコンポーネントの上部に新しいステートを作成します。"
  },
  {
    "start": 3789974,
    "end": 3791758,
    "text": "私たちは以前にもこのようなことをしている。"
  },
  {
    "start": 3791934,
    "end": 3794410,
    "text": "私たちはスクラップ記録でコンストを作る。"
  },
  {
    "start": 3794790,
    "end": 3797942,
    "text": "これをuse stateに割り当て、デフォルト値とする。"
  },
  {
    "start": 3798006,
    "end": 3799930,
    "text": "今回は空文字列を渡す。"
  },
  {
    "start": 3800690,
    "end": 3806470,
    "text": "ここでもまた、入力と呼ぶ状態があり、ゼータz入力と呼ぶ。"
  },
  {
    "start": 3806770,
    "end": 3811850,
    "text": "デフォルト値のため、ここでも型は文字列と推測される。"
  },
  {
    "start": 3812010,
    "end": 3819350,
    "text": "ここで、入力フィールドに値を設定することによって、入力フィールドをコントロールされた入力フィールドに変える。"
  },
  {
    "start": 3819770,
    "end": 3835702,
    "text": "このように保存し、ここにカーソルを置いて文字を入力すると、もうそこに文字を入力することはできない。なぜなら、この内部状態を上書きしてしまうからである。"
  },
  {
    "start": 3835806,
    "end": 3836974,
    "text": "私たちはこれを更新することはない。"
  },
  {
    "start": 3837062,
    "end": 3839450,
    "text": "だからここでは何も入力できない。"
  },
  {
    "start": 3839790,
    "end": 3854820,
    "text": "onchangepropによって再びステートを変更する。ここでも、現在の入力を含むreactイベントを取得し、ここでステート・セッターを呼び出すことができる。"
  },
  {
    "start": 3855520,
    "end": 3862340,
    "text": "これを別の関数にすることもできるが、これはたった1行のコードなので、次のようにインライン関数として書くことができる。"
  },
  {
    "start": 3862880,
    "end": 3868780,
    "text": "ここでは、eドットのターゲット・ドット値から再び新しい入力値を得る。"
  },
  {
    "start": 3869160,
    "end": 3872408,
    "text": "これでまた入力フィールドに何か入力できる。"
  },
  {
    "start": 3872584,
    "end": 3879160,
    "text": "これで、この状態は入力ステート変数に格納され、よりコントロールしやすくなった。"
  },
  {
    "start": 3879280,
    "end": 3883456,
    "text": "では、フォームを送信するときにだけ何かをしたいのですね？"
  },
  {
    "start": 3883608,
    "end": 3886460,
    "text": "これを整理するために別の機能にしてみよう。"
  },
  {
    "start": 3887280,
    "end": 3889260,
    "text": "ハンドルサブミットと呼ぼう。"
  },
  {
    "start": 3890960,
    "end": 3906548,
    "text": "ここでsubmit型のボタンをクリックすると、フォームが送信されます。この場合、submit関数にこの関数を渡すことで、何をするかを決めることができます。"
  },
  {
    "start": 3906744,
    "end": 3917700,
    "text": "さて、このonsubmit関数はイベントをハンドルのsubmit関数に渡すが、別の関数として宣言したので、この引数の型も明示的に設定しなければならない。"
  },
  {
    "start": 3917740,
    "end": 3918908,
    "text": "これは推論ではない。"
  },
  {
    "start": 3919004,
    "end": 3926076,
    "text": "この型が何なのかを知るために、ちょっとだけ、この下のハンドルサブミットを削除して、エラー関数を渡してみよう。"
  },
  {
    "start": 3926188,
    "end": 3930644,
    "text": "Ntvscodesのツールチップは、これがどのような引数を想定しているかを教えてくれる。"
  },
  {
    "start": 3930772,
    "end": 3941512,
    "text": "これはreact formイベントタイプで、HTML formエレメントタイプです。"
  },
  {
    "start": 3941656,
    "end": 3964320,
    "text": "デフォルトでは、HTMLフォームを送信すると、postリクエストが送信され、ページが更新されます。"
  },
  {
    "start": 3964400,
    "end": 3966928,
    "text": "これはHTMLのデフォルトの動作である。"
  },
  {
    "start": 3967024,
    "end": 3970592,
    "text": "リアクトでは、フォームを別の方法で扱いたいことがよくある。"
  },
  {
    "start": 3970656,
    "end": 3974896,
    "text": "このonsubmit関数を通してJavaScriptコードで処理したい。"
  },
  {
    "start": 3975008,
    "end": 3977064,
    "text": "ページがリフレッシュされるのを避けるためです。"
  },
  {
    "start": 3977112,
    "end": 3983620,
    "text": "e-preventdefaultを呼び出さなければならないが、あとはすべて入力状態が処理してくれる。"
  },
  {
    "start": 3984080,
    "end": 3989758,
    "text": "まず第一に、新しいTodoを追加するのは、入力フィールドが空でない場合だけですよね？"
  },
  {
    "start": 3989934,
    "end": 4003518,
    "text": "感嘆符の入力がトリム関数として呼び出され、各行の終わりと始まりの空白が取り除かれているかどうかをチェックする。"
  },
  {
    "start": 4003574,
    "end": 4007694,
    "text": "この場合も入力なしとカウントされる。"
  },
  {
    "start": 4007742,
    "end": 4011250,
    "text": "この関数から戻るだけで、他には何もしたくない。"
  },
  {
    "start": 4011790,
    "end": 4014912,
    "text": "もし有効な入力を提出したら、何をしたいのか？"
  },
  {
    "start": 4015046,
    "end": 4019820,
    "text": "さて、このフォームを使う親にこの入力を渡したい。"
  },
  {
    "start": 4019940,
    "end": 4020388,
    "text": "なぜですか？"
  },
  {
    "start": 4020484,
    "end": 4025412,
    "text": "なぜなら、To Doリストの状態はフォーム自体ではなく、親コンポーネントにあるからだ。"
  },
  {
    "start": 4025556,
    "end": 4027508,
    "text": "ここで更新しなければならない。"
  },
  {
    "start": 4027604,
    "end": 4037760,
    "text": "コールバックを介してこれを行う方法はすでに知っているので、新しいインターフェイスを作成し、コンポーネント関数自体の上にtodoform propsを追加する。"
  },
  {
    "start": 4039620,
    "end": 4052520,
    "text": "このonsubmitコールバック関数は、新しいTodoのタイトルを引数として受け取り、何も返しません。"
  },
  {
    "start": 4052860,
    "end": 4056876,
    "text": "この関数の引数を宣言し、小道具を再構築する。"
  },
  {
    "start": 4056908,
    "end": 4064200,
    "text": "この中括弧の下にtodoformpropsを追加し、この中にonsubmit関数がある。"
  },
  {
    "start": 4065940,
    "end": 4078556,
    "text": "次に、handlesubmitgestの内部で、onsubmitcallbackを呼び出し、usestateに格納されているcurrentinputstateを渡します。"
  },
  {
    "start": 4078708,
    "end": 4083360,
    "text": "もうひとつ、入力を空文字列に戻したい。"
  },
  {
    "start": 4083700,
    "end": 4094600,
    "text": "なぜなら、こうすることで入力をよりコントロールすることができ、また空の状態に戻すといったことができるからだ。"
  },
  {
    "start": 4095430,
    "end": 4108210,
    "text": "これを保存して、Todo追加フォームにこの呼び出しを戻し、送信時にaddtodoを呼び出します。"
  },
  {
    "start": 4109430,
    "end": 4115862,
    "text": "これをset todocompletedの下に置き、後でこれらの関数をここに整理することにしよう。"
  },
  {
    "start": 4115926,
    "end": 4127664,
    "text": "今のところ、この1つのファイルに保存しておくだけだ。タイトルを文字列として保存し、新しいTodoerを作成してTodos配列に入れる。"
  },
  {
    "start": 4127792,
    "end": 4132424,
    "text": "繰り返すが、既存の状態を変更することはできない。"
  },
  {
    "start": 4132472,
    "end": 4135100,
    "text": "トドをプッシュと呼ぶわけにはいかない。"
  },
  {
    "start": 4136120,
    "end": 4146008,
    "text": "その代わりに、set todosを呼び出して、その中に新しいTodoを含む新しい参照を持つ、まったく新しい配列を渡さなければならない。"
  },
  {
    "start": 4146184,
    "end": 4152852,
    "text": "エラー関数を渡す。"
  },
  {
    "start": 4152996,
    "end": 4157916,
    "text": "今回はmapを呼び出さないが、ここではまだ配列を返す必要がある。"
  },
  {
    "start": 4158028,
    "end": 4163820,
    "text": "配列リテラルを作成し、この配列に新しいTodoオブジェクトを入れる。"
  },
  {
    "start": 4163980,
    "end": 4166320,
    "text": "中かっこでオブジェクトを作る。"
  },
  {
    "start": 4166820,
    "end": 4171400,
    "text": "ステートの型がtodoarrayなので、ここでオートコンプリートを得る。"
  },
  {
    "start": 4172780,
    "end": 4178374,
    "text": "最後のアイテムのidに1を足したものをideaとする。"
  },
  {
    "start": 4178422,
    "end": 4184610,
    "text": "データベースを使えば、これは自動的に処理される。"
  },
  {
    "start": 4185150,
    "end": 4189930,
    "text": "息のトドメの長さを取って、1つ追加するだけだ。"
  },
  {
    "start": 4191590,
    "end": 4200050,
    "text": "タイトルは入力フィールドからの入力で、デフォルトではfalseにリセットされる。"
  },
  {
    "start": 4200350,
    "end": 4211410,
    "text": "そして、このオブジェクトの後に、dosへの接頭辞を置きたい。"
  },
  {
    "start": 4211490,
    "end": 4211778,
    "text": "そうだろう？"
  },
  {
    "start": 4211834,
    "end": 4218362,
    "text": "既存のTODOと、配列の一番上に追加される新しいTODOをここに入れたい。"
  },
  {
    "start": 4218506,
    "end": 4225514,
    "text": "リストの一番下に新しい項目を追加したい場合は、この配列のbreathtodosの後に追加する必要がある。"
  },
  {
    "start": 4225682,
    "end": 4228910,
    "text": "そして、これを保存すれば、うまくいくはずだ。"
  },
  {
    "start": 4231250,
    "end": 4234690,
    "text": "このように、我々はDOSに新しいものを加えることができる。"
  },
  {
    "start": 4234850,
    "end": 4235594,
    "text": "いいね。"
  },
  {
    "start": 4235762,
    "end": 4238842,
    "text": "さて、話を続ける前に、ちょっとしたクイズを出そう。"
  },
  {
    "start": 4238946,
    "end": 4247082,
    "text": "あなたは、私たちがどのように新しいドスを私たちの状態に更新することができるのか、そしてどのように既存の状態を更新することができるのか、あなたが学んだすべての情報とそれに基づいて知っている。"
  },
  {
    "start": 4247226,
    "end": 4251162,
    "text": "やることリストから項目を削除する方法を考えてみよう。"
  },
  {
    "start": 4251266,
    "end": 4257768,
    "text": "完全に新しい配列を渡さなければならないことを覚えておいてほしい。"
  },
  {
    "start": 4257904,
    "end": 4265608,
    "text": "このビデオを見続ける前に、少し時間を取り、このことについて考え、そしてあなたの解決策をこのビデオにコメントを書いてください。"
  },
  {
    "start": 4265744,
    "end": 4271952,
    "text": "この練習をすることで、知識を定着させ、反応しながら考えることができるようになるからだ。"
  },
  {
    "start": 4272096,
    "end": 4273640,
    "text": "間違っても心配しないで。"
  },
  {
    "start": 4273720,
    "end": 4275744,
    "text": "すぐに解決策を説明しよう。"
  },
  {
    "start": 4275872,
    "end": 4281184,
    "text": "簡単なことではないが、自分で何かを考え出そうとすれば、それは本当に学習の助けになる。"
  },
  {
    "start": 4281312,
    "end": 4290494,
    "text": "ビデオの下のコメント欄にあなたの解決策を記入してください。そして、To Doリストに削除機能とソート機能を追加して続けましょう。"
  },
  {
    "start": 4290662,
    "end": 4293574,
    "text": "このTodos配列をソートしたい。"
  },
  {
    "start": 4293702,
    "end": 4297662,
    "text": "完了したToDoはリストの一番下に置きたい。"
  },
  {
    "start": 4297806,
    "end": 4309050,
    "text": "繰り返しになるが、ソート・ロジックをアプリ・コンポーネントに直接入れることもできるが、そうすると、このコンポーネントの中に多くのものが入ってしまうので、整理するために別のコンポーネントに取り出すのが理にかなっている。"
  },
  {
    "start": 4309470,
    "end": 4317590,
    "text": "実際、To DoリストをレンダリングしているこのDiv全体を切り取り、別のコンポーネントにしたい。"
  },
  {
    "start": 4317890,
    "end": 4336710,
    "text": "このTodoリストのTSXエクスポート・デフォルト関数を、いつものように同じ名前で呼び、先ほど切り取ったdivを返すようにします。"
  },
  {
    "start": 4337370,
    "end": 4342830,
    "text": "もちろん、小道具も必要だし、このto doアイテムもインポートしなければならない。"
  },
  {
    "start": 4344170,
    "end": 4352954,
    "text": "次に、この関数の上に行き、リストを作成するための新しいインターフェイスを宣言してみよう。"
  },
  {
    "start": 4353082,
    "end": 4368416,
    "text": "TODO自体も必要だし、未完了の変更に対するコールバックも必要だ。なぜなら、ステートはまだアプリ・コンポーネントの中にあり、親にステートを渡す必要があるからだ。"
  },
  {
    "start": 4368528,
    "end": 4380632,
    "text": "やることリストの状態をこのコンポーネントに移さない理由は、やることリストの下に第3のコンポーネントがあり、そこにもTodoの状態が必要だからだ。"
  },
  {
    "start": 4380736,
    "end": 4388304,
    "text": "先ほどの図を思い出してほしいが、私たちは常に、このステートを使用するコンポーネントから独立した状態を保ちたいのだ。"
  },
  {
    "start": 4388432,
    "end": 4391340,
    "text": "これらのプロップをインターフェイスに追加しよう。"
  },
  {
    "start": 4392160,
    "end": 4395110,
    "text": "To doはtodoarray型である。"
  },
  {
    "start": 4395190,
    "end": 4404158,
    "text": "ここでも、Todoアイテムコンポーネントと同じタイプを持つ未完了の変更タイプをインポートしなければならない。"
  },
  {
    "start": 4404294,
    "end": 4409654,
    "text": "この機能全体と3つ目の機能を転送するだけだ。"
  },
  {
    "start": 4409702,
    "end": 4413542,
    "text": "また、このリストからTodoを削除できるようにしたい。"
  },
  {
    "start": 4413606,
    "end": 4423880,
    "text": "後でondeleteと呼ぶが、ここでは削除したいアイテムのアイデアと、それをステートから削除することだけが必要である。"
  },
  {
    "start": 4425220,
    "end": 4427676,
    "text": "この小道具を分解してみよう。"
  },
  {
    "start": 4427748,
    "end": 4437520,
    "text": "ここでもtodoリスト・プロップス型で、ここではtodoistのoncompleted changeとon deleteを持っている。"
  },
  {
    "start": 4438140,
    "end": 4440924,
    "text": "ここではまだTodo項目をレンダリングしている。"
  },
  {
    "start": 4441012,
    "end": 4447324,
    "text": "ただ、オンコンプリートされた変更については、同じ名前の関数を渡さなければならなくなった。"
  },
  {
    "start": 4447412,
    "end": 4449200,
    "text": "これを親に渡す。"
  },
  {
    "start": 4449780,
    "end": 4462280,
    "text": "アプリのTSXファイルに入り、このTodoリストをレンダリングしよう。"
  },
  {
    "start": 4462660,
    "end": 4470280,
    "text": "変更完了時に set todoscompletedcallback 関数を渡します。"
  },
  {
    "start": 4471020,
    "end": 4472852,
    "text": "これは今でも同じだ。"
  },
  {
    "start": 4472956,
    "end": 4473500,
    "text": "ただそれだけだ。"
  },
  {
    "start": 4473540,
    "end": 4476664,
    "text": "もう一段階、レベルを上げなければならない。"
  },
  {
    "start": 4476792,
    "end": 4485408,
    "text": "このコールバックをページからTodoリスト、Todoアイテムに渡し、そこでこのコールバックをトリガーする必要がある。"
  },
  {
    "start": 4485504,
    "end": 4489944,
    "text": "これはプロップ・トリリングと呼ばれ、複数のレイヤーにプロップを通す。"
  },
  {
    "start": 4490112,
    "end": 4496032,
    "text": "もちろん、ある時点で、これを複数のレイヤーに通さなければならなくなると、これはあまりに面倒になる。"
  },
  {
    "start": 4496136,
    "end": 4503632,
    "text": "より高度なチュートリアルで使用するreact contextのようなソリューションもあるが、今のところはprop drillingで十分だ。"
  },
  {
    "start": 4503736,
    "end": 4506328,
    "text": "削除の取り消しについては、すぐに対応します。"
  },
  {
    "start": 4506384,
    "end": 4508740,
    "text": "とりあえず、このリストを並べ替えたい。"
  },
  {
    "start": 4509400,
    "end": 4514248,
    "text": "これは、Todoリスト・コンポーネントのreturn文の上でできる。"
  },
  {
    "start": 4514384,
    "end": 4518460,
    "text": "ここでは、Todoをソートして呼び出すconstを作成する。"
  },
  {
    "start": 4519120,
    "end": 4526380,
    "text": "私たちはプロップとして渡されたトドスの状態を受け取り、それをリコール・ソートする。"
  },
  {
    "start": 4527160,
    "end": 4539942,
    "text": "ソートするには、エラー関数を渡す。エラー関数には2つの引数が渡され、2つの引数は単にaとbと呼ばれることが多い。"
  },
  {
    "start": 4540086,
    "end": 4565122,
    "text": "なぜなら、ソート関数は数値を返す必要があり、この数値が要素を並べる順番を決めるからである。"
  },
  {
    "start": 4565306,
    "end": 4568590,
    "text": "このロジックを詳しく理解する必要はない。"
  },
  {
    "start": 4568970,
    "end": 4572590,
    "text": "これによってどのようにエレメントが分類されるかは、後ほどお見せしよう。"
  },
  {
    "start": 4572970,
    "end": 4584830,
    "text": "このifブロックの下、まだソート関数の中にあるが、ドットで補完されたクエスチョンマーク、1コロンマイナス1を返す。"
  },
  {
    "start": 4585530,
    "end": 4589778,
    "text": "なぜこれを別のコンポーネントにしたかったのか、その理由もおわかりいただけるだろう。"
  },
  {
    "start": 4589834,
    "end": 4597382,
    "text": "というのも、このようなものをすべてアプリコンポーネント・コンポーネントに入れると、非常に読みづらくなり、すぐに整理できなくなってしまうからだ。"
  },
  {
    "start": 4597566,
    "end": 4610462,
    "text": "これを別のやることリスト・コンポーネントに入れることで、このロジックをカプセル化しておくことができ、また、このコードを繰り返すことなく、同じやることリストを別のページに入れることができるので、再利用も可能になる。"
  },
  {
    "start": 4610606,
    "end": 4611406,
    "text": "オーケー、クールだ。"
  },
  {
    "start": 4611478,
    "end": 4618570,
    "text": "ここでTODOをレンダリングする代わりに、単純にTODOソートを使う。"
  },
  {
    "start": 4619060,
    "end": 4622860,
    "text": "これを保存すると、ToDoは再びソートされる。"
  },
  {
    "start": 4622900,
    "end": 4634240,
    "text": "ソート・ロジックはこの中にあり、このロジックは、すべての完了した仕事を一番下に置くが、チェックを外すとリストに戻す。"
  },
  {
    "start": 4635140,
    "end": 4639964,
    "text": "もちろん、必要であればソートのロジックをカスタマイズすることもできるが、これはかなりクールだと思う。"
  },
  {
    "start": 4640052,
    "end": 4643196,
    "text": "ここでリアクトについて理解しておくべき重要なことがある。"
  },
  {
    "start": 4643348,
    "end": 4649210,
    "text": "コンポーネントが再レンダリングされるたびに、この関数の本体が再度実行される。"
  },
  {
    "start": 4649330,
    "end": 4657682,
    "text": "つまり、例えばTODOSの状態や他のプロップや状態が変更されると、このコードが再び実行される。"
  },
  {
    "start": 4657826,
    "end": 4671698,
    "text": "このため、データベース操作のようなサイドエフェクトをコンポーネントのボディに直接入れないことが重要なのだ。"
  },
  {
    "start": 4671794,
    "end": 4676546,
    "text": "後ほど、より構造化された方法で副作用を実行する方法を学ぶ。"
  },
  {
    "start": 4676618,
    "end": 4681954,
    "text": "ソート関数をここに入れても、副作用がないので問題ない。"
  },
  {
    "start": 4682042,
    "end": 4685930,
    "text": "この配列をソートして、その値を変数に格納するだけである。"
  },
  {
    "start": 4686050,
    "end": 4692954,
    "text": "コンポーネントをレンダリングするたびにソート関数を実行するのはコストがかかるのではないか？"
  },
  {
    "start": 4693002,
    "end": 4695770,
    "text": "それはよくあることで、いい指摘だ。"
  },
  {
    "start": 4695890,
    "end": 4700322,
    "text": "このような配列のカリングソートは、非常に安価な操作である。"
  },
  {
    "start": 4700386,
    "end": 4704122,
    "text": "非常に高速なので、レンダリングごとに実行しても問題ない。"
  },
  {
    "start": 4704226,
    "end": 4712474,
    "text": "もしtodosが何万もの要素を持つような巨大な配列であったなら、これをより効率的にすることに意味があるだろう。"
  },
  {
    "start": 4712562,
    "end": 4715010,
    "text": "これをより効率的にするフックがある。"
  },
  {
    "start": 4715090,
    "end": 4722658,
    "text": "Todoistのpropsが変更された時だけソート関数を実行し、他の状態が変更された時には実行しないようにすることができる。"
  },
  {
    "start": 4722754,
    "end": 4728682,
    "text": "これは最適化であり、この操作が実際に高価な場合にのみ行うべきである。"
  },
  {
    "start": 4728866,
    "end": 4737034,
    "text": "比較的小さな配列の場合、これは非常に安価な操作であり、レンダリングごとに簡単に実行できる。"
  },
  {
    "start": 4737202,
    "end": 4744162,
    "text": "このような高度なケースの例を見たい場合は、私の大きなプロジェクトのチュートリアルを見てください。"
  },
  {
    "start": 4744306,
    "end": 4747610,
    "text": "よし、次はTodoを削除する方法を追加しよう。"
  },
  {
    "start": 4747730,
    "end": 4751218,
    "text": "今頃は削除ロジックでコメントを残してくれているといいのだが。"
  },
  {
    "start": 4751314,
    "end": 4752858,
    "text": "怖がることはない。"
  },
  {
    "start": 4753034,
    "end": 4755848,
    "text": "次に、Todoアイテム・コンポーネントに入る。"
  },
  {
    "start": 4755994,
    "end": 4764560,
    "text": "ラベルの外側に削除ボタンを置きたい。"
  },
  {
    "start": 4765540,
    "end": 4774720,
    "text": "ここにある小文字のボタンは、先ほどインストールしたlucid reactパッケージからインポートしたもので、ゴミ箱をアイコンに置きたい。"
  },
  {
    "start": 4775860,
    "end": 4780080,
    "text": "ちなみにサイズは小道具で、20に設定した。"
  },
  {
    "start": 4782190,
    "end": 4785022,
    "text": "これを閉じると、アイコンがある。"
  },
  {
    "start": 4785166,
    "end": 4786750,
    "text": "少しスタイリッシュにしたい。"
  },
  {
    "start": 4786790,
    "end": 4791774,
    "text": "このテキストにグレーの500を与えてグレーにしたい。"
  },
  {
    "start": 4791902,
    "end": 4795530,
    "text": "次に、これらの要素を適切に配置するために、divにスタイルを設定します。"
  },
  {
    "start": 4796110,
    "end": 4807636,
    "text": "これをフレックスボックスにすることで、1行の項目が中央に配置され、ラベルの間隔が1つ空きます。"
  },
  {
    "start": 4807708,
    "end": 4809828,
    "text": "ここでもうひとつクラスを追加する。"
  },
  {
    "start": 4810004,
    "end": 4813268,
    "text": "最初でも最後でも構わない。"
  },
  {
    "start": 4813444,
    "end": 4819320,
    "text": "アイコンを除いた幅いっぱいに表示されます。"
  },
  {
    "start": 4819660,
    "end": 4821924,
    "text": "それからボタンに向かう。"
  },
  {
    "start": 4821972,
    "end": 4830036,
    "text": "ボタンにもまた、2つのパディングを持つクラスを追加する。"
  },
  {
    "start": 4830228,
    "end": 4839206,
    "text": "最後に、このボタンにはクリック・ハンドラが必要で、このハンドラに引数なしで矢印関数を渡す。"
  },
  {
    "start": 4839358,
    "end": 4843890,
    "text": "繰り返しになるが、これは1行しかないので、別の関数には入れていない。"
  },
  {
    "start": 4844270,
    "end": 4848910,
    "text": "ここでは、まだ作成していないundeleteコールバックを呼び出します。"
  },
  {
    "start": 4848990,
    "end": 4849910,
    "text": "そうしよう"
  },
  {
    "start": 4849950,
    "end": 4857750,
    "text": "ここで、Todoアイテムのプロップスで、To Doリストと同じundeleteコールバックを宣言します。"
  },
  {
    "start": 4857830,
    "end": 4863060,
    "text": "これをここに置くんだ。"
  },
  {
    "start": 4866080,
    "end": 4875980,
    "text": "それをクリック・ハンドラーに呼び出し、そのハンドラーに、ここでレンダリングするこのアイデアを渡すだけだ。"
  },
  {
    "start": 4876400,
    "end": 4880480,
    "text": "よし、To Doリストにやることをレンダリングしよう。"
  },
  {
    "start": 4880600,
    "end": 4887270,
    "text": "これはつまり、プロップが削除されることを期待し、これを親ページに転送することを意味する。"
  },
  {
    "start": 4887430,
    "end": 4905170,
    "text": "そして最後のステップとして、アプリのtsxファイルにdeleteコールバックを渡します。"
  },
  {
    "start": 4906470,
    "end": 4916980,
    "text": "ここではreturn文の上に、削除されたTodoのidを引数に取る関数delete todoを置いた。"
  },
  {
    "start": 4917400,
    "end": 4920820,
    "text": "ここでもまた、設定されたTodoで状態を更新しなければならない。"
  },
  {
    "start": 4921280,
    "end": 4932344,
    "text": "ここでも、前のTodoを通過して、削除した項目を取り除いた新しい配列を返さなければならない。"
  },
  {
    "start": 4932432,
    "end": 4936220,
    "text": "prevからdoistを取り出し、filterを呼び出す。"
  },
  {
    "start": 4937090,
    "end": 4946786,
    "text": "ここでは、各Todoにエラー関数を渡し、削除したTodoを除くすべてのTodoをリストに残す。"
  },
  {
    "start": 4946978,
    "end": 4963490,
    "text": "ここで、Todoアイディアがこの関数に渡したidと一致しない場合のみ、そのidを配列に保持し、一致したidを配列から削除する。"
  },
  {
    "start": 4963570,
    "end": 4965666,
    "text": "アイテムの削除を試してみましょう。"
  },
  {
    "start": 4965738,
    "end": 4967190,
    "text": "このボタンをクリックすればいい。"
  },
  {
    "start": 4967580,
    "end": 4969188,
    "text": "項目は削除されます。"
  },
  {
    "start": 4969364,
    "end": 4971828,
    "text": "ページを更新すると、それらはすべて戻っている。"
  },
  {
    "start": 4971964,
    "end": 4975500,
    "text": "また、新しい項目を追加したり、削除したりすることもできる。"
  },
  {
    "start": 4975540,
    "end": 4977228,
    "text": "それをチェックし、削除することもできる。"
  },
  {
    "start": 4977324,
    "end": 4977956,
    "text": "いいね。"
  },
  {
    "start": 4978108,
    "end": 4979360,
    "text": "もう2つある。"
  },
  {
    "start": 4979740,
    "end": 4986840,
    "text": "ひとつは、下にたくさんの項目を追加すると、パディングがなくなってしまうことだ。"
  },
  {
    "start": 4987300,
    "end": 4993636,
    "text": "この問題は、メイン・タグにoverflow while autoを追加することで解決できる。"
  },
  {
    "start": 4993828,
    "end": 5001828,
    "text": "これで上下に適切なパディングができるようになった。"
  },
  {
    "start": 5001964,
    "end": 5008972,
    "text": "すべてのToDoを削除するときに、リストにまだToDoがないという小さなテキストを表示したい。"
  },
  {
    "start": 5009076,
    "end": 5014800,
    "text": "条件付きでテキストをレンダリングする方法を学ぶことができるからだ。"
  },
  {
    "start": 5015300,
    "end": 5022480,
    "text": "もう一度To Doリスト・コンポーネントに入って、このdivの外側に空のテキストをレンダリングしよう。"
  },
  {
    "start": 5022790,
    "end": 5031462,
    "text": "return文は親要素を1つ必要とするので、下にもう1つdivを置くことはできない。"
  },
  {
    "start": 5031646,
    "end": 5037582,
    "text": "を別のdivに折り返すこともできるが、そうすると不要なdivができてしまう。"
  },
  {
    "start": 5037726,
    "end": 5041182,
    "text": "もうひとつできることは、このように空のフラグメントを使うことだ。"
  },
  {
    "start": 5041326,
    "end": 5048624,
    "text": "これにより、基本的に複数の親要素をここに置くことができ、それらはページ内部でレンダリングされる。"
  },
  {
    "start": 5048822,
    "end": 5057760,
    "text": "このフラグメントの中で、divの下にtodosの長さを書く式を追加する。"
  },
  {
    "start": 5058700,
    "end": 5061076,
    "text": "これがゼロに等しいかどうかをチェックしたい。"
  },
  {
    "start": 5061148,
    "end": 5072600,
    "text": "この配列が空であれば、2つの袂と符号を持つことになるので、JavaScriptの論理演算子または演算子は、この式が真である場合にのみ、条件付きでコンポーネントをレンダリングすることができる。"
  },
  {
    "start": 5073550,
    "end": 5087170,
    "text": "ここで括弧を2つ作り、DOSにノーという段落をレンダリングし、その上に新しい段落を追加する。"
  },
  {
    "start": 5088350,
    "end": 5091570,
    "text": "また、この段落を少しスタイリッシュにしたい。"
  },
  {
    "start": 5091950,
    "end": 5093286,
    "text": "すでにある。"
  },
  {
    "start": 5093398,
    "end": 5096370,
    "text": "テキストをテキストセンターでセンタリングしたい。"
  },
  {
    "start": 5097630,
    "end": 5104610,
    "text": "スミスのテキストで小さくしたいし、グレーの500に設定したい。"
  },
  {
    "start": 5105030,
    "end": 5105810,
    "text": "いいね。"
  },
  {
    "start": 5106110,
    "end": 5108502,
    "text": "この要素は条件付きでレンダリングされる。"
  },
  {
    "start": 5108606,
    "end": 5110966,
    "text": "Todoを追加すると、それが消えてしまう。"
  },
  {
    "start": 5111078,
    "end": 5114358,
    "text": "このTodoを削除しても、またそこにある。"
  },
  {
    "start": 5114414,
    "end": 5116390,
    "text": "これが反応することの素晴らしさだ。"
  },
  {
    "start": 5116510,
    "end": 5119238,
    "text": "UI全体が完璧に同期している。"
  },
  {
    "start": 5119334,
    "end": 5122894,
    "text": "特定のテキストの表示・非表示のタイミングを気にする必要はない。"
  },
  {
    "start": 5123022,
    "end": 5127044,
    "text": "どのような状況でそれを見せたいかを宣言し、反応するだけだ。"
  },
  {
    "start": 5127132,
    "end": 5131148,
    "text": "常に最新の状態を画面に描画する。"
  },
  {
    "start": 5131284,
    "end": 5134280,
    "text": "さて、ここではまだいくつかのリントエラーがある。"
  },
  {
    "start": 5134820,
    "end": 5139348,
    "text": "このimport文を削除すればいいだけだ。"
  },
  {
    "start": 5139524,
    "end": 5147676,
    "text": "次に、完了したToDoの数を表示する新しいコンポーネントを作りたい。"
  },
  {
    "start": 5147748,
    "end": 5150604,
    "text": "これがreactで副作用を実行する方法である。"
  },
  {
    "start": 5150692,
    "end": 5152656,
    "text": "それを見逃さないように。"
  },
  {
    "start": 5152828,
    "end": 5156960,
    "text": "componentsフォルダに新しいコンポーネントを作りましょう。"
  },
  {
    "start": 5157080,
    "end": 5166104,
    "text": "私たちは、Todo要約TSXエクスポート・デフォルト機能と呼んでいる。"
  },
  {
    "start": 5166152,
    "end": 5174856,
    "text": "要約を行うには、要約用の小道具のインターフェイスが必要だ。"
  },
  {
    "start": 5174928,
    "end": 5176400,
    "text": "私たちはそのプロだ。"
  },
  {
    "start": 5176480,
    "end": 5183580,
    "text": "Todoの配列が必要なので、todoarray."
  },
  {
    "start": 5184920,
    "end": 5197744,
    "text": "UIのこのセクションには、完了したTodoを一度に削除できるボタンがあるので、delete all completedというコールバックも追加したい。"
  },
  {
    "start": 5197912,
    "end": 5203334,
    "text": "もちろん、これはコールバックとして渡さなければならない。"
  },
  {
    "start": 5203512,
    "end": 5212202,
    "text": "そして、いつものように、これらのプロップをコンポーネントの引数で再構築し、サマリー・プロップを行う必要がある。"
  },
  {
    "start": 5212386,
    "end": 5229114,
    "text": "完了したTodoの数をレンダリングしたいので、const completed todoistエントリーを作りましょう。"
  },
  {
    "start": 5229162,
    "end": 5239758,
    "text": "このTodoフィルターに、このエラー関数の各Todoを取り込み、完了したものだけをこのリストに残す。"
  },
  {
    "start": 5239934,
    "end": 5244990,
    "text": "繰り返しますが、このフィルター操作は、このコンポーネントが再レンダリングされるたびに実行されます。"
  },
  {
    "start": 5245110,
    "end": 5248410,
    "text": "また、これは安い作戦だからいいんだ。"
  },
  {
    "start": 5248750,
    "end": 5254450,
    "text": "これをコンポーネント本体で直接行い、UI要素をレンダリングすることができる。"
  },
  {
    "start": 5256390,
    "end": 5263910,
    "text": "ここにdivを置き、text centerとspace yツールでスタイルを設定する。"
  },
  {
    "start": 5266130,
    "end": 5273510,
    "text": "このdivには、完了したtodoの長さをレンダリングする段落タグを入れます。"
  },
  {
    "start": 5274290,
    "end": 5289566,
    "text": "そして中括弧の外側には、フィルタリングされていない配列の長さを示す中括弧todosがあり、その外側にはテキストtodosがある。"
  },
  {
    "start": 5289678,
    "end": 5291438,
    "text": "これを我々のアプリに入れよう。"
  },
  {
    "start": 5291614,
    "end": 5296170,
    "text": "フォームとTo Doリストを含むdivの外側に置きたい。"
  },
  {
    "start": 5296630,
    "end": 5310050,
    "text": "メインの閉じタグの上にあるdivの下に、Todo要約コンポーネントを置く。"
  },
  {
    "start": 5310780,
    "end": 5322796,
    "text": "この削除完了コールバックを終了する。今は、コードをコンパイルするために、このように空のarrow関数を渡すだけだが、この関数は後で処理する。"
  },
  {
    "start": 5322868,
    "end": 5326140,
    "text": "では、ページを更新して、これらのコンポーネントのひとつをチェックしてみよう。"
  },
  {
    "start": 5326180,
    "end": 5330120,
    "text": "ご覧のように、状態はすぐに更新される。"
  },
  {
    "start": 5330860,
    "end": 5333396,
    "text": "このテキストに少しスタイルをつけたい。"
  },
  {
    "start": 5333508,
    "end": 5339530,
    "text": "段落のテキストSMとフォントの媒体にクラス名を追加します。"
  },
  {
    "start": 5339690,
    "end": 5348350,
    "text": "もしこの数値が0を超えたら、全削除完了コールバックをトリガーするボタンを表示したい。"
  },
  {
    "start": 5348690,
    "end": 5352074,
    "text": "条件付きレンダリングのやり方はもう知っているよね？"
  },
  {
    "start": 5352242,
    "end": 5355510,
    "text": "段落の下に中括弧を追加する。"
  },
  {
    "start": 5356210,
    "end": 5360910,
    "text": "完了したtodoの長さが0より大きいかどうかをチェックする。"
  },
  {
    "start": 5361580,
    "end": 5375560,
    "text": "アマゾンの記号を2つ使って、条件付きでコンポーネントをレンダリングしたり、通常のHTML要素の括弧を使ったりする。"
  },
  {
    "start": 5378340,
    "end": 5399450,
    "text": "このボタンがクリックされると、削除が完了したコールバックが呼び出されます。"
  },
  {
    "start": 5399750,
    "end": 5404570,
    "text": "これがすべてのクラスで、これがその結果だ。"
  },
  {
    "start": 5405110,
    "end": 5417650,
    "text": "このボタンが表示されるのは、少なくとも1つのチェックが入っているときだけです。このボタンを適切にフォーマットして保存し、アプリのページでこのコールバックを処理しましょう。"
  },
  {
    "start": 5418340,
    "end": 5426480,
    "text": "完了したTodoをすべて削除する」という新しい関数が必要だ。"
  },
  {
    "start": 5426900,
    "end": 5429000,
    "text": "ここで議論する必要はない。"
  },
  {
    "start": 5429860,
    "end": 5433080,
    "text": "もう一度、Todoの状態を更新する必要がある。"
  },
  {
    "start": 5433980,
    "end": 5436200,
    "text": "ここでもまた、トドメの一撃が必要だ。"
  },
  {
    "start": 5436820,
    "end": 5441668,
    "text": "もう一度、ビデオを一時停止して、自分で考えてみることをお勧めする。"
  },
  {
    "start": 5441804,
    "end": 5444908,
    "text": "通常のTodo削除機能はすでにありますよね？"
  },
  {
    "start": 5445044,
    "end": 5448948,
    "text": "完了したすべてのToDoをフィルタリングするにはどう書けばいいのだろう？"
  },
  {
    "start": 5449084,
    "end": 5450480,
    "text": "そんなに難しいことじゃない。"
  },
  {
    "start": 5450860,
    "end": 5453724,
    "text": "じゃあ、3、2、1で解決だね。"
  },
  {
    "start": 5453892,
    "end": 5455764,
    "text": "私たちはトドスと呼んでいる。"
  },
  {
    "start": 5455932,
    "end": 5465876,
    "text": "もう一度フィルターを呼び出すが、今度は完了していないすべてのTodoをフィルターする。"
  },
  {
    "start": 5465908,
    "end": 5476882,
    "text": "ここでは冒頭に感嘆符を付けているが、完了していないドスだけをこの新しい配列に残し、この更新された配列から最新の状態をセットしたい。"
  },
  {
    "start": 5477026,
    "end": 5481310,
    "text": "あとは、この関数をその名前で渡すだけだ。"
  },
  {
    "start": 5482130,
    "end": 5483306,
    "text": "それだけだ。"
  },
  {
    "start": 5483458,
    "end": 5493666,
    "text": "Todoをチェックしたり、一度に削除したり、ドアに新しいものを追加したり、削除したりすることができる。"
  },
  {
    "start": 5493818,
    "end": 5499670,
    "text": "僕らのUIにはバグがあるんだ。もちろん、僕が意図的に入れたんだけどね。"
  },
  {
    "start": 5499770,
    "end": 5501490,
    "text": "簡単なバグだ。"
  },
  {
    "start": 5502350,
    "end": 5509286,
    "text": "ここで、新しいTodoerのidには、現在の配列の長さに1を足したものを渡す。"
  },
  {
    "start": 5509358,
    "end": 5531770,
    "text": "なぜなら、4つ目の要素を追加して3つ目の要素を削除し、さらに4つ目の要素を追加すると、2つの要素がid 4を持つことになり、先ほど見たように、削除ボタンをクリックしたときに間違ったTodoを削除してしまうからです。"
  },
  {
    "start": 5532230,
    "end": 5536686,
    "text": "繰り返しますが、実際のプロダクションアプリでは、このidはデータベースから取得されます。"
  },
  {
    "start": 5536758,
    "end": 5539254,
    "text": "通常、その心配はない。"
  },
  {
    "start": 5539342,
    "end": 5541246,
    "text": "ここではユニークな値が必要だ。"
  },
  {
    "start": 5541318,
    "end": 5547646,
    "text": "これを処理する簡単な方法は、現在のタイムスタンプをミリ秒単位で日付と一緒に使うことだ。"
  },
  {
    "start": 5547758,
    "end": 5549702,
    "text": "これで十分だろう。"
  },
  {
    "start": 5549846,
    "end": 5557138,
    "text": "すべてのアイデアはユニークであるべきだし、リストは適切に機能しなければならない。"
  },
  {
    "start": 5557194,
    "end": 5574070,
    "text": "いくつかの項目を削除し、いくつかの項目をチェックし、さらにいくつかの項目を削除し、チェックし、チェックを外し、チェックし、新しい項目を追加し、そのうちのひとつを削除する。"
  },
  {
    "start": 5574850,
    "end": 5581766,
    "text": "さて、次は副作用について学び、コードを整理するために独自のカスタム・フックを作成しよう。"
  },
  {
    "start": 5581858,
    "end": 5586622,
    "text": "しかし、この2つのトピックは見逃せない。"
  },
  {
    "start": 5586766,
    "end": 5595838,
    "text": "さて、ボタンをクリックしたり、フォームを送信したり、その他のユーザー・イベントが発生したときに、コールバックを使ってコードを実行できることは、すでに知っている。"
  },
  {
    "start": 5595934,
    "end": 5604774,
    "text": "状態が変化したときや、コンポーネントを初めて画面にレンダリングしたときに、サイドエフェクトを実行したいことがある。"
  },
  {
    "start": 5604862,
    "end": 5611842,
    "text": "繰り返しになるが、このロジックをコンポーネント本体に直接入れることはできない。"
  },
  {
    "start": 5611966,
    "end": 5618350,
    "text": "代わりに、これらの副作用をuseeffectで実行する。これも重要なリアクトフックだ。"
  },
  {
    "start": 5618650,
    "end": 5623750,
    "text": "ここでは関数の上に、使用状態の下に置いてみよう。"
  },
  {
    "start": 5624130,
    "end": 5635690,
    "text": "このuseeffectフックを呼び出し、そのフックに中括弧のブロックを取得するエラー関数を渡す。"
  },
  {
    "start": 5635810,
    "end": 5638190,
    "text": "この配列には依存関係が含まれる。"
  },
  {
    "start": 5638560,
    "end": 5646600,
    "text": "この配列の中に何も渡さなかった場合、このエフェクトは、このコンポーネントを最初に画面に配置したときに実行される。"
  },
  {
    "start": 5646760,
    "end": 5650160,
    "text": "すべてのレンダリングではなく、最初のレンダリングだけだ。"
  },
  {
    "start": 5650320,
    "end": 5662288,
    "text": "例えばTodosのステートのように、ここにステートを入れたり、ここにプロップを入れたりすると、このエフェクトはこの値が変化したときだけ実行される。"
  },
  {
    "start": 5662424,
    "end": 5674820,
    "text": "この例では、ブラウザのローカルストレージにTodosの状態を保存し、リフレッシュの度に現在の状態を保存するようにします。"
  },
  {
    "start": 5674900,
    "end": 5678492,
    "text": "でも、保存ボタンをクリックする必要もない。"
  },
  {
    "start": 5678636,
    "end": 5683316,
    "text": "その代わりに、このTodos配列の状態が変わるたびにこれを保存したい。"
  },
  {
    "start": 5683428,
    "end": 5689332,
    "text": "アイテムを追加、削除、更新するたびに、自動的にローカル・ストレージに保存する。"
  },
  {
    "start": 5689436,
    "end": 5695906,
    "text": "そしてここには、localstorage zitemという1行があるだけだ。"
  },
  {
    "start": 5696098,
    "end": 5699050,
    "text": "文字列の形でキーを与えなければならない。"
  },
  {
    "start": 5699090,
    "end": 5700670,
    "text": "Todoistと呼ぼう。"
  },
  {
    "start": 5701690,
    "end": 5705554,
    "text": "ローカル・ストレージには文字列しか保存できない。"
  },
  {
    "start": 5705682,
    "end": 5719550,
    "text": "大文字のドットでJSONを記述し、文字列化してTodos配列を渡すと、Todosの状態が変わるたびに、これが文字列に変換されてローカル・ストレージに保存される。"
  },
  {
    "start": 5720630,
    "end": 5727650,
    "text": "クロームの開発ツールで、アプリケーションのタブを開くと、f twelveですでに見ることができる。"
  },
  {
    "start": 5728110,
    "end": 5731010,
    "text": "ここでローカルストレージを見ることができる。"
  },
  {
    "start": 5731470,
    "end": 5735806,
    "text": "トドスの配列はすでにある。"
  },
  {
    "start": 5735918,
    "end": 5747700,
    "text": "これで、何かを変更するたびに、useeffectは更新された値をローカル・ストレージに保存し、常に最新の状態に保つことができる。"
  },
  {
    "start": 5749720,
    "end": 5755144,
    "text": "ページを更新するときに、ローカル・ストレージからこの状態をロードしたいんだよね？"
  },
  {
    "start": 5755232,
    "end": 5764704,
    "text": "これは、空の依存性配列を使って別のエフェクトを使用することで、コンポーネントを初めて画面にレンダリングするときにのみ実行される。"
  },
  {
    "start": 5764792,
    "end": 5772642,
    "text": "よりシンプルで効率的な方法は、ダミーデータの代わりにuse stateイニシャライザーで直接これを行うことだ。"
  },
  {
    "start": 5772826,
    "end": 5779630,
    "text": "また、このようにエラー関数をここに渡してロジックを実行し、初期値を返すこともできる。"
  },
  {
    "start": 5780050,
    "end": 5786230,
    "text": "ここでは、保存したTodoをローカル・ストレージから取得したい。"
  },
  {
    "start": 5786730,
    "end": 5794510,
    "text": "文字列にしてしまったので、オブジェクトに戻す必要があるが、これはJSONパスでできる。"
  },
  {
    "start": 5795010,
    "end": 5801542,
    "text": "ここでは、同じTodoistキーを持つローカルストレージのgetitemを渡している。"
  },
  {
    "start": 5801686,
    "end": 5811206,
    "text": "getitemは、このキーが存在しない場合はnullを返すことができる。"
  },
  {
    "start": 5811278,
    "end": 5819770,
    "text": "この場合、空の配列にフォールバックしたいが、まだJSONパス関数の中にいるので、これは文字列でなければならない。"
  },
  {
    "start": 5820590,
    "end": 5826340,
    "text": "さて、保存したToDoを返したい。"
  },
  {
    "start": 5826640,
    "end": 5829980,
    "text": "保存されたTodoの長さをチェックしたい。"
  },
  {
    "start": 5830280,
    "end": 5834976,
    "text": "ここでは、オートコンプリートは使えない。"
  },
  {
    "start": 5835008,
    "end": 5838780,
    "text": "Todo配列として明示的に型を設定することができる。"
  },
  {
    "start": 5839720,
    "end": 5846544,
    "text": "safetodosの長さが0より大きい場合、クエスチョンマーク。"
  },
  {
    "start": 5846592,
    "end": 5848660,
    "text": "トドメを刺したい。"
  },
  {
    "start": 5849000,
    "end": 5851456,
    "text": "そうでなければ、ダミーデータを返したい。"
  },
  {
    "start": 5851608,
    "end": 5859040,
    "text": "もしすべての項目を削除してページを更新したら、ダミーのデータをローカル・ストレージと配列に入れたい。"
  },
  {
    "start": 5859200,
    "end": 5861140,
    "text": "これがここに入れたものだ。"
  },
  {
    "start": 5861440,
    "end": 5864160,
    "text": "念のため、ページを更新してみよう。"
  },
  {
    "start": 5864280,
    "end": 5871488,
    "text": "これで、新しい項目を追加したり、既存の項目にチェックを入れたりすることができ、ページを更新すると以前の状態に戻る。"
  },
  {
    "start": 5871624,
    "end": 5872352,
    "text": "いいね。"
  },
  {
    "start": 5872536,
    "end": 5875140,
    "text": "これはローカル・ストレージに保存される。"
  },
  {
    "start": 5875560,
    "end": 5883730,
    "text": "すべてのTodoを削除し、ページをリフレッシュすると、再びダミーデータが表示され、ローカル・ストレージに保存される。"
  },
  {
    "start": 5883890,
    "end": 5888150,
    "text": "これで、リアクトに必要なものの70％はわかっただろう。"
  },
  {
    "start": 5888570,
    "end": 5891042,
    "text": "もうひとつ、このチュートリアルでやりたいことがある。"
  },
  {
    "start": 5891226,
    "end": 5893146,
    "text": "このロジックは本当に厄介だ。"
  },
  {
    "start": 5893218,
    "end": 5896426,
    "text": "この1つのコンポーネントの中に、たくさんのコードが含まれているんだ。"
  },
  {
    "start": 5896578,
    "end": 5899970,
    "text": "これをカスタムフックに入れることで、よりよく整理することができる。"
  },
  {
    "start": 5900050,
    "end": 5901506,
    "text": "次はそうしよう。"
  },
  {
    "start": 5901658,
    "end": 5908342,
    "text": "前にも述べたように、useで始まるこれらの機能はすべてフックと呼ばれる。"
  },
  {
    "start": 5908406,
    "end": 5911910,
    "text": "リアクトでは、ユーステート、ユースエフェクト、他にもいくつかある。"
  },
  {
    "start": 5911990,
    "end": 5917638,
    "text": "これらのフックは、コンポーネントの内部か、他のフックの内部でしか呼び出すことができない。"
  },
  {
    "start": 5917734,
    "end": 5920030,
    "text": "どうすれば自分たちのフックを作れるのか？"
  },
  {
    "start": 5920110,
    "end": 5924130,
    "text": "では、同じようにuseという単語で始まる関数を作ればいい。"
  },
  {
    "start": 5924550,
    "end": 5925970,
    "text": "そうしよう"
  },
  {
    "start": 5926630,
    "end": 5929278,
    "text": "srzフォルダに新しいファイルを作成しよう。"
  },
  {
    "start": 5929374,
    "end": 5938470,
    "text": "まずhooksというフォルダを作り、その中にuse todos tsdemというフックを入れる。"
  },
  {
    "start": 5939410,
    "end": 5949578,
    "text": "ここでは、usetodosというデフォルトの関数をエクスポートする。今回はコンポーネントではないので、小文字のuを使う。"
  },
  {
    "start": 5949754,
    "end": 5955066,
    "text": "次に、アプリのtsxに戻って、このコードをすべて取り出します。"
  },
  {
    "start": 5955098,
    "end": 5964100,
    "text": "Todosの状態から、useeffectとすべての関数、returnブロックより上のすべての関数を始める。"
  },
  {
    "start": 5964180,
    "end": 5970764,
    "text": "これを切り取り、use todos関数の中に直接貼り付ける。"
  },
  {
    "start": 5970892,
    "end": 5975612,
    "text": "インポートをいくつか修正しなければならないので、これらをすべてインポートしよう。"
  },
  {
    "start": 5975676,
    "end": 5977932,
    "text": "最後の一文字を消しただけだ。"
  },
  {
    "start": 5978076,
    "end": 5988884,
    "text": "自動インポートを使うには、ダミーデータの使用効果が必要だ。"
  },
  {
    "start": 5988972,
    "end": 5991960,
    "text": "他のものは使われていない機能だ。"
  },
  {
    "start": 5992260,
    "end": 6002820,
    "text": "例えば、todosを取得するために名前を変更しようとすると、react hookという警告が表示される。"
  },
  {
    "start": 6002860,
    "end": 6009724,
    "text": "Usdateは、リアクトの関数コンポーネントでもカスタムリアクトフックでもない関数gettodosで呼び出されます。"
  },
  {
    "start": 6009772,
    "end": 6010444,
    "text": "機能。"
  },
  {
    "start": 6010572,
    "end": 6014372,
    "text": "Reactのコンポーネント名は大文字で始まる必要があります。"
  },
  {
    "start": 6014436,
    "end": 6017712,
    "text": "Reactのフック名はuseで始まる必要がある。"
  },
  {
    "start": 6017876,
    "end": 6019536,
    "text": "それがここでの要点だ。"
  },
  {
    "start": 6019648,
    "end": 6026368,
    "text": "リアクトフックを別の関数に取り出したい場合、この関数は必ずuseで始まる必要がある。"
  },
  {
    "start": 6026504,
    "end": 6028168,
    "text": "それが命名規則だ。"
  },
  {
    "start": 6028264,
    "end": 6037376,
    "text": "この命名規則が強制されているのは、そうしないとreactの開発者がこの関数の内部でreactフックを使っていることを知らないからだ。"
  },
  {
    "start": 6037488,
    "end": 6041240,
    "text": "これではリアクトのコードを書いたりデバッグしたりするのが本当に難しくなる。"
  },
  {
    "start": 6041320,
    "end": 6048542,
    "text": "というのも、ステートや副作用が普通の関数の中に隠されていると、何が起こっているのかを理解するのがとても難しくなるからだ。"
  },
  {
    "start": 6048656,
    "end": 6053426,
    "text": "これが、この命名規則がある理由であり、reactでカスタムフックを作成する方法である。"
  },
  {
    "start": 6053498,
    "end": 6054690,
    "text": "魔法じゃないんだ。"
  },
  {
    "start": 6054810,
    "end": 6058026,
    "text": "フックは引数を取ることもできる。"
  },
  {
    "start": 6058178,
    "end": 6059378,
    "text": "うちは違う。"
  },
  {
    "start": 6059474,
    "end": 6065130,
    "text": "アプリのページでこれらの関数や値を使うには、まだ方法が必要なんだ。"
  },
  {
    "start": 6065250,
    "end": 6068042,
    "text": "を返すだけでいい。"
  },
  {
    "start": 6068226,
    "end": 6071990,
    "text": "この関数の最後にreturn文を追加する。"
  },
  {
    "start": 6072290,
    "end": 6074950,
    "text": "ここではトドメの状態を返す。"
  },
  {
    "start": 6076400,
    "end": 6087496,
    "text": "私たちの異なる機能、set todocompleted、add todo、delete all completed、delete todo。"
  },
  {
    "start": 6087688,
    "end": 6089368,
    "text": "全員いるはずだ。"
  },
  {
    "start": 6089544,
    "end": 6099180,
    "text": "そしてページに戻り、constを作成して再構築し、新しいusetodosフックを呼び出す。"
  },
  {
    "start": 6099760,
    "end": 6102700,
    "text": "ここでは、これらの値をすべて見つけることができる。"
  },
  {
    "start": 6103140,
    "end": 6114200,
    "text": "私たちの状態、todoerの追加、todo完了の設定、todoの削除、完了したすべての削除。"
  },
  {
    "start": 6114940,
    "end": 6117880,
    "text": "未使用のimport文を削除する。"
  },
  {
    "start": 6118460,
    "end": 6121196,
    "text": "これで我々のアプリは以前と同じように動作する。"
  },
  {
    "start": 6121308,
    "end": 6126800,
    "text": "ただ、すべてのロジックがこのフックに隠されているため、コードがより整理されている。"
  },
  {
    "start": 6127100,
    "end": 6131352,
    "text": "また、必要であれば、これを別のコンポーネントで再利用することもできる。"
  },
  {
    "start": 6131516,
    "end": 6133856,
    "text": "まだ使えるかどうか試してみよう。"
  },
  {
    "start": 6133888,
    "end": 6137060,
    "text": "ページはまだローカル・ストレージに保存されている。"
  },
  {
    "start": 6137440,
    "end": 6144780,
    "text": "ToDoを追加したり、削除したり、完了させたりしても、まったく同じように機能する。"
  },
  {
    "start": 6145320,
    "end": 6146160,
    "text": "完璧だ。"
  },
  {
    "start": 6146320,
    "end": 6149032,
    "text": "この反応する初心者コースを楽しんでいただけたなら幸いだ。"
  },
  {
    "start": 6149136,
    "end": 6154792,
    "text": "繰り返しになるが、私の無料の反応ベストプラクティスEメールコースもぜひ受講されることをお勧めする。"
  },
  {
    "start": 6154896,
    "end": 6157312,
    "text": "このチュートリアルにぴったりだ。"
  },
  {
    "start": 6157376,
    "end": 6162530,
    "text": "数日間、毎日ちょっとしたベストプラクティスを教える。"
  },
  {
    "start": 6162690,
    "end": 6170898,
    "text": "ここでも、codingandflow.com reactbestpracticesで見つけることができるが、もちろんこれはほんの始まりに過ぎない。"
  },
  {
    "start": 6170954,
    "end": 6182090,
    "text": "データベースの使い方、ルーティング、データの取得、メタデータ、サーバーサイドレンダリング、さらに高度なリアクトフックなど、学ばなければならないトピックはまだまだある。"
  },
  {
    "start": 6182170,
    "end": 6193118,
    "text": "私はいつも、このような高度なトピックはプロジェクトを作ることで学ぶことをお勧めしている。"
  },
  {
    "start": 6193174,
    "end": 6195486,
    "text": "そのほとんどは次のJSにいる。"
  },
  {
    "start": 6195638,
    "end": 6200070,
    "text": "私はまた、エクスプレスJのバックエンドを別に構築したマーン・コースも持っている。"
  },
  {
    "start": 6200190,
    "end": 6205438,
    "text": "次のjsを学びたいなら、僕のウェブデヴ・プレイリストをチェックしてくれ。"
  },
  {
    "start": 6205494,
    "end": 6214962,
    "text": "特に、次のJS 14の初心者向けチュートリアルがありますが、このプレイリストの中にもあるので、プレイリストと必要な他のリソースをリンクしておきます。"
  },
  {
    "start": 6215086,
    "end": 6219042,
    "text": "今後もチュートリアルをお届けしますので、チャンネル登録をお忘れなく。"
  },
  {
    "start": 6219186,
    "end": 6224106,
    "text": "また、このビデオに「いいね！」を残してください。"
  },
  {
    "start": 6224218,
    "end": 6234834,
    "text": "このチュートリアルや私のチュートリアルを気に入ってくれる人がいたら、ぜひシェアしてください。"
  },
  {
    "start": 6234922,
    "end": 6236730,
    "text": "それでは、また次のビデオでお会いしましょう。"
  },
  {
    "start": 6236810,
    "end": 6237578,
    "text": "ハッピーなコーディングだ。"
  },
  {
    "start": 6237634,
    "end": 6237970,
    "text": "気をつけて。"
  }
]
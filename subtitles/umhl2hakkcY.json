[
  {
    "start": 0,
    "end": 10000,
    "text": "みなさん、Apps from Scratchへようこそ。"
  },
  {
    "start": 10000,
    "end": 14400,
    "text": "今日は、YouTubeのダークモードのユーザーインターフェースの作り方を教えよう。"
  },
  {
    "start": 14400,
    "end": 24960,
    "text": "スリヴァーの使い方や、ミニ・プレーヤー・パッケージを使って選択したビデオを下のナビゲーション・バーの上に表示する方法、さらにはアプリの状態を管理するための基本的なリバー・ポッドの使い方も学べます。"
  },
  {
    "start": 24960,
    "end": 43080,
    "text": "このビデオでは、クリーンで美しいユーザー体験を開発するのに役立つ、簡単なUIトリックをいくつか紹介する。"
  },
  {
    "start": 43080,
    "end": 47120,
    "text": "いいね！」ボタンを押し、チャンネル登録することをお忘れなく。"
  },
  {
    "start": 47120,
    "end": 52640,
    "text": "Flutterを使って実際のアプリを作る方法を学びたい方は、LaunchClub.ioの私のコースをチェックしてください。"
  },
  {
    "start": 52640,
    "end": 55080,
    "text": "本題に入ろう。"
  },
  {
    "start": 55080,
    "end": 59960,
    "text": "以下のスターター・プロジェクトに、フォローアップに必要なすべてのモック・データをリンクした。"
  },
  {
    "start": 59960,
    "end": 64519,
    "text": "スターター・ブランチにいることを確認し、zipファイルをダウンロードする。"
  },
  {
    "start": 64519,
    "end": 71160,
    "text": "スターター・プロジェクトを開くと、main.dartとdata.dartの2つのファイルが表示される。"
  },
  {
    "start": 71160,
    "end": 81660,
    "text": "main.dartのビルド・メソッドで最初にすることは、ユーザーが誤って横向きに変えてしまわないように、好ましい向きを縦向きに設定することだ。"
  },
  {
    "start": 81660,
    "end": 87020,
    "text": "次にマテリアルアプリを返し、タイトルをFlutter YouTube UIに設定する。"
  },
  {
    "start": 87020,
    "end": 91580,
    "text": "debugShowCheckedModeBannerをfalseに設定することで、デバッグ・バナーを非表示にする。"
  },
  {
    "start": 91580,
    "end": 97940,
    "text": "次にテーマ・データを指定し、明るさをbrightness.darkに設定して、このアプリをダーク・モードにする。"
  },
  {
    "start": 97940,
    "end": 105380,
    "text": "次に、ナビゲーション・バー下部のテーマを設定し、選択されたアイテムの色をcolors.whiteにします。"
  },
  {
    "start": 105380,
    "end": 108580,
    "text": "私たちはここで足場を組み立てる。"
  },
  {
    "start": 108780,
    "end": 113259,
    "text": "data.dartの中では、ファイルの一番上にユーザー・クラスを定義した。"
  },
  {
    "start": 113259,
    "end": 122259,
    "text": "これは、現在のユーザーを作成できるようにするためで、ユーザーはユーザー名、プロフィール画像、購読者数を持ちます。"
  },
  {
    "start": 122259,
    "end": 126060,
    "text": "これはすべて、アプリに表示する情報だ。"
  },
  {
    "start": 126060,
    "end": 132100,
    "text": "次に、ビデオ・クラスを作成しました。ビデオには、注意しなければならないさまざまなプロパティがあります。"
  },
  {
    "start": 132100,
    "end": 136540,
    "text": "シミュレーターを見ると、ここに3つのビデオがあるのがわかる。"
  },
  {
    "start": 136540,
    "end": 140220,
    "text": "これらのビデオは、このビデオリストの中で定義されています。"
  },
  {
    "start": 140220,
    "end": 148579,
    "text": "最初にClubhouseクローン、次にBuild Flutter Apps Fast、そして一番下にInstagram Stories。"
  },
  {
    "start": 148579,
    "end": 157780,
    "text": "ユーザーがこれらの動画の1つをタップすると、動画情報が表示され、作者情報の下にはお勧め動画のリストが表示されます。"
  },
  {
    "start": 157780,
    "end": 163060,
    "text": "これらの推奨ビデオは、この下のリストに定義されている。"
  },
  {
    "start": 163060,
    "end": 170540,
    "text": "環境を2.12.0に設定したので、このプロジェクトはヌル・セーフをサポートしています。"
  },
  {
    "start": 170540,
    "end": 177300,
    "text": "依存関係はFlutter RiverPod、MiniPlayer、TimeAgoの3つ。"
  },
  {
    "start": 177300,
    "end": 185380,
    "text": "基本的な状態管理にはRiverPodを使用しています。ビデオを選択すると、この一番上で状態が変化するのがわかります。"
  },
  {
    "start": 185380,
    "end": 196140,
    "text": "ビデオ画面をMiniPlayerにすると、下にビデオが表示され、ユーザーが新しいビデオを選択すると、プレーヤーが変更されます。"
  },
  {
    "start": 196140,
    "end": 201340,
    "text": "RiverPodを使うのは、このアプリにとって素晴らしいことだ。"
  },
  {
    "start": 201340,
    "end": 206740,
    "text": "RiverPodを使ったことがなくても、心配しないでください。"
  },
  {
    "start": 206740,
    "end": 208380,
    "text": "次はミニプレーヤーだ。"
  },
  {
    "start": 208380,
    "end": 216020,
    "text": "MiniPlayerでは、このコンテナを下に置いて、それを上にドラッグするか、クリックすると、ビデオ画面に展開されます。"
  },
  {
    "start": 216020,
    "end": 223740,
    "text": "ユーザーが左上のボタンをタップしてビデオ画面を最小化すると、アニメーションでミニプレーヤーに戻ります。"
  },
  {
    "start": 223740,
    "end": 229780,
    "text": "これは素晴らしいパッケージだ。僕らが必要としていることを正確にやってくれるし、車輪の再発明に時間を費やす必要もない。"
  },
  {
    "start": 229780,
    "end": 236420,
    "text": "最後にTimeAgoパッケージがあり、これは各動画が持つ日付時間を変更することができる。"
  },
  {
    "start": 236420,
    "end": 247140,
    "text": "例えば、FacebookのクローンレスポンシブUIチュートリアルに8-7-2020という日付があります。"
  },
  {
    "start": 247140,
    "end": 253980,
    "text": "したがって、TimeAgoパッケージはこのdatetimeをTimeAgo文字列に変換している。"
  },
  {
    "start": 253980,
    "end": 262460,
    "text": "最後にPubSpecに追加したのはアセットで、このアセットはassetsフォルダの中にあるYouTubeのロゴです。"
  },
  {
    "start": 262460,
    "end": 265380,
    "text": "これはダークモードのYouTubeロゴだ。"
  },
  {
    "start": 265380,
    "end": 269740,
    "text": "私たちはこのロゴをアプリバーに使用しています。"
  },
  {
    "start": 269740,
    "end": 276380,
    "text": "最初に取り組むのは、ナビゲーション画面の一番下にあるナビゲーション・バーです。"
  },
  {
    "start": 276380,
    "end": 285040,
    "text": "Screensというフォルダを作り、最初のファイルをnavScreen.dartとしよう。"
  },
  {
    "start": 285040,
    "end": 293000,
    "text": "これはnavScreenと呼ばれるステートフルウィジェットになり、マテリアルをインポートする必要がある。"
  },
  {
    "start": 293000,
    "end": 307740,
    "text": "main.dartに戻って、HomeウィジェットをnavScreenに置き換えて、それをインポートします。"
  },
  {
    "start": 307740,
    "end": 314820,
    "text": "下部のナビゲーション・バーを作成するには、scaffoldウィジェットにbottomNavigationBarを追加します。"
  },
  {
    "start": 314820,
    "end": 321540,
    "text": "BottomNavigationBarでは、いくつかの項目を定義する必要がある。"
  },
  {
    "start": 321540,
    "end": 340560,
    "text": "最初のアイテムはbottomNavigationBarItemとし、アイコンをiconIcons.HomeOutlinedに設定し、ラベルをHomeとします。"
  },
  {
    "start": 340560,
    "end": 350380,
    "text": "bottomNavigationBarItemが選択されたときにアクティブになるアイコンを設定します。"
  },
  {
    "start": 350380,
    "end": 359420,
    "text": "アイテムが選択されていないときは、輪郭のないアイコンが表示され、アイテムが選択されると、塗りつぶされたホームアイコンが表示される。"
  },
  {
    "start": 359420,
    "end": 368740,
    "text": "これを4回繰り返して、保存を押すと、選択したホーム・アイテムが下に表示される。"
  },
  {
    "start": 368740,
    "end": 375659,
    "text": "他のアイコンをタップしても何も起こらないが、それはまだonTapメソッドを設定していないからだ。"
  },
  {
    "start": 375659,
    "end": 383900,
    "text": "その前に、エクスプローラー、追加、購読、ライブラリーのアイコンを正しく設定しよう。"
  },
  {
    "start": 383900,
    "end": 390820,
    "text": "icons.ExploreOutlined、そしてExplore.Explore.Exploreとする。"
  },
  {
    "start": 390820,
    "end": 409860,
    "text": "次に、AddCircleOutlined、AddCircle、SubscriptionsOutlined、Subscriptionsがある。"
  },
  {
    "start": 409860,
    "end": 421380,
    "text": "最終的にLibraryとなり、これはVideo.LibraryOutlinedとなります。"
  },
  {
    "start": 421380,
    "end": 429860,
    "text": "ユーザーがさまざまなアイコンをタップし、選択されているアイコンを変更できるようにするには、SelectedIndex変数を追加する必要がある。"
  },
  {
    "start": 429860,
    "end": 434820,
    "text": "intのSelectedIndexを持ち、それを0に設定する。"
  },
  {
    "start": 434820,
    "end": 439900,
    "text": "一番下のナビゲーション・バーでは、CurrentIndexをSelectedIndexに設定します。"
  },
  {
    "start": 439900,
    "end": 453860,
    "text": "ユーザーがこれらの下部ナビゲーション・バー項目のいずれかをタップすると、SetStateを呼び出し、SelectedIndexをSelectedIndexに設定します。"
  },
  {
    "start": 453860,
    "end": 458460,
    "text": "アイコンをクリックすると、それに応じてアイコンが更新される。"
  },
  {
    "start": 458460,
    "end": 468460,
    "text": "シフト効果をオフにするには、タイプをBottomNavigationBarType.Fixedに設定すればよい。"
  },
  {
    "start": 468460,
    "end": 471580,
    "text": "アイコンの色も修正された。"
  },
  {
    "start": 471580,
    "end": 488260,
    "text": "SelectedFontSizeを10.0に設定し、UnselectedFontSizeも10.0に設定することで、統一されます。"
  },
  {
    "start": 488260,
    "end": 495060,
    "text": "今気づいたんだけど、AddCircleが埋まっている。"
  },
  {
    "start": 495060,
    "end": 499340,
    "text": "これは Outlined ではなく AddCircleOutline とすべきである。"
  },
  {
    "start": 499340,
    "end": 501880,
    "text": "これで間違いなさそうだ。"
  },
  {
    "start": 501880,
    "end": 507460,
    "text": "この下のナビゲーション・バーと比較してみると、まさにその通りだ。"
  },
  {
    "start": 507460,
    "end": 514100,
    "text": "それでは、ユーザーが下のナビゲーション・バー項目のどれかをタップしたときに、正しい画面を表示するようにしましょう。"
  },
  {
    "start": 514100,
    "end": 519700,
    "text": "スタック・ウィジェットを使い、それをオフステージ・ウィジェットと組み合わせる。"
  },
  {
    "start": 519700,
    "end": 528540,
    "text": "Stack \"ウィジェットで5つの画面をすべて重ねて表示し、\"Offstage \"ウィジェットで現在選択されている画面以外のすべての画面を非表示にします。"
  },
  {
    "start": 528540,
    "end": 533100,
    "text": "これは、複数のナビゲーション・スタックを持つ必要があるアプリを開発するときにとても便利だ。"
  },
  {
    "start": 533100,
    "end": 544860,
    "text": "ホーム画面内でナビゲートし、ライブラリ画面に切り替えてその画面内でナビゲートする場合、アプリはこれらの各画面のナビゲーション・スタックを記憶することができる。"
  },
  {
    "start": 544860,
    "end": 552860,
    "text": "このビルド・メソッドをリロードするたびに再レンダリングしないように、アイテムを定数にする必要がある。"
  },
  {
    "start": 552860,
    "end": 554400,
    "text": "次に、いくつかのスクリーンを定義する。"
  },
  {
    "start": 554400,
    "end": 561380,
    "text": "Final」、「Screens」、そして「Home」画面があります。"
  },
  {
    "start": 561380,
    "end": 572800,
    "text": "「Cont」、「Scaffold」、「Body」、「Center」、「Child」、「Text」、「Explore」。"
  },
  {
    "start": 572800,
    "end": 575760,
    "text": "これをあと3回コピーしよう。"
  },
  {
    "start": 575760,
    "end": 584960,
    "text": "次に「Add」、「Subscriptions」、「Library」。"
  },
  {
    "start": 584960,
    "end": 591040,
    "text": "ホーム画面はScreensフォルダの中にHomeScreen.dartとして作成されます。"
  },
  {
    "start": 591040,
    "end": 594760,
    "text": "これはHomeScreenと呼ばれるステートレス・ウィジェットになる。"
  },
  {
    "start": 594760,
    "end": 600960,
    "text": "マテリアルをインポートし、とりあえず足場を返す。"
  },
  {
    "start": 600960,
    "end": 605560,
    "text": "これでこの画面をNavScreenにインポートできる。"
  },
  {
    "start": 605560,
    "end": 614200,
    "text": "Scaffoldの本体には、Screens、SelectedIndexを使用します。"
  },
  {
    "start": 614200,
    "end": 620144,
    "text": "前にも話したように、ホーム画面の中を移動して、「エクスプローラー」に切り替えるとしよう、"
  },
  {
    "start": 620144,
    "end": 627360,
    "text": "追加、購読、ライブラリーの画面を表示し、ホーム画面に戻っても、実際には今クリックした画面しか表示されません。"
  },
  {
    "start": 627360,
    "end": 630920,
    "text": "画面を切り替えるたびに、各画面のナビゲーション・スタック全体が失われることになる。"
  },
  {
    "start": 631920,
    "end": 642920,
    "text": "これを回避する方法は、スタック・ウィジェットを作成し、スクリーンをマップとしてマッピングすることである。"
  },
  {
    "start": 642920,
    "end": 643920,
    "text": "地図"
  },
  {
    "start": 643920,
    "end": 648920,
    "text": "スクリーンのリストをマップに変えたので、インデックスがわかった。"
  },
  {
    "start": 648920,
    "end": 651920,
    "text": "次に、各スクリーンにScreen."
  },
  {
    "start": 651920,
    "end": 659240,
    "text": "これをマップ・エントリーにし、キーはインデックスとする。"
  },
  {
    "start": 660240,
    "end": 664240,
    "text": "ここにいる子どもはスクリーンだけだ。"
  },
  {
    "start": 664240,
    "end": 671240,
    "text": "次に、マップを値に変換し、それをリストに変えることができる。"
  },
  {
    "start": 671240,
    "end": 676240,
    "text": "offstageにカーソルを合わせると、ウィジェットが作成され、子供が視覚的に隠されるのがわかる。"
  },
  {
    "start": 676240,
    "end": 679240,
    "text": "現在選択されている画面だけを表示したい。"
  },
  {
    "start": 679240,
    "end": 686240,
    "text": "SelectedIndexがiと等しくない場合は、offstageを設定することができる。"
  },
  {
    "start": 686240,
    "end": 689240,
    "text": "これで、選択されていない画面はすべて非表示になる。"
  },
  {
    "start": 689240,
    "end": 697240,
    "text": "すべての画面がレンダリングされるが、選択されたものだけが表示されるため、各画面のナビゲーション・スタックを保持することができる。"
  },
  {
    "start": 697240,
    "end": 703240,
    "text": "これらを切り替えてみると、完璧に機能していることがわかる。"
  },
  {
    "start": 703240,
    "end": 706240,
    "text": "次に、アプリ・バーに取り組みます。"
  },
  {
    "start": 706240,
    "end": 709240,
    "text": "ユーザーが上にスクロールすると、アプリバーが消えるようにしたい。"
  },
  {
    "start": 709240,
    "end": 713240,
    "text": "スクロールダウンしたときに、アプリバーが表示されるようにします。"
  },
  {
    "start": 713240,
    "end": 718240,
    "text": "この効果を得るために、スライバー・アプリバーを使用する。"
  },
  {
    "start": 718240,
    "end": 723240,
    "text": "ホーム画面の中に、本体を作りましょう。"
  },
  {
    "start": 723240,
    "end": 727240,
    "text": "これはカスタムスクロールビューになる。"
  },
  {
    "start": 727240,
    "end": 733240,
    "text": "カスタムスクロールビューはスライバーを取り込むので、スライバーアプリバーを持つことができる。"
  },
  {
    "start": 733240,
    "end": 740240,
    "text": "まずYouTubeのロゴを追加し、次にアイコンボタンを追加しよう。"
  },
  {
    "start": 740240,
    "end": 751240,
    "text": "image.asset、assets.youtube、logo.dark.pngをリードする。"
  },
  {
    "start": 751240,
    "end": 755240,
    "text": "これは、プロジェクト内のYouTubeロゴへのルートです。"
  },
  {
    "start": 755240,
    "end": 762240,
    "text": "先頭の幅を100.0にしてサイズを大きくしてみよう。"
  },
  {
    "start": 762240,
    "end": 766240,
    "text": "これにパディングを加えることができる。"
  },
  {
    "start": 766240,
    "end": 773240,
    "text": "edgeInsets.onlyを左12.0に設定。"
  },
  {
    "start": 773240,
    "end": 776240,
    "text": "次にこれらのアクションを処理しよう。"
  },
  {
    "start": 776240,
    "end": 787240,
    "text": "アクションをiconButton、iconConst、iconIcons.castに設定します。"
  },
  {
    "start": 787240,
    "end": 791240,
    "text": "onPressedは空にしておく。"
  },
  {
    "start": 791240,
    "end": 795240,
    "text": "これをあと3回繰り返してみよう。"
  },
  {
    "start": 795240,
    "end": 805240,
    "text": "次はnotificationsOutlined、検索だ。"
  },
  {
    "start": 805240,
    "end": 813240,
    "text": "最後に、アイコンの代わりに円のアバターを使用します。"
  },
  {
    "start": 813240,
    "end": 817240,
    "text": "circleAvatar, foregroundImage."
  },
  {
    "start": 817240,
    "end": 821240,
    "text": "networkImage.currentUserにアクセスできる。"
  },
  {
    "start": 821240,
    "end": 828240,
    "text": "この現在のユーザーは、data.dart ファイル.profileImageUrl."
  },
  {
    "start": 828240,
    "end": 832240,
    "text": "アイコンのサイズを40.0に増やしてみよう。"
  },
  {
    "start": 832240,
    "end": 835240,
    "text": "UIのように見える。"
  },
  {
    "start": 835240,
    "end": 843240,
    "text": "YouTubeアプリは複数の画面にわたってSliverアプリバーを使用しているため、独自のウィジェットに抽出する必要があります。"
  },
  {
    "start": 843240,
    "end": 855240,
    "text": "それを切り取って、今度はWidgetsフォルダにcustomSliverAppBar.dartを作ります。"
  },
  {
    "start": 855240,
    "end": 867240,
    "text": "これはステートレスで、customSliverAppBarをインポートし、マテリアルをインポートし、先ほどカットしたものを貼り付け、data.dartをインポートします。"
  },
  {
    "start": 867240,
    "end": 874240,
    "text": "ホーム画面に戻り、customSliverAppBarと入力します。"
  },
  {
    "start": 874240,
    "end": 884240,
    "text": "インポートする前に、Widgets.dartというバレル・ファイルを作って、インポートを整理しておこう。"
  },
  {
    "start": 884240,
    "end": 892240,
    "text": "エクスポートし、Widgets.dart.CustomSliverAppBar をインポートします。"
  },
  {
    "start": 892240,
    "end": 902240,
    "text": "ユーザーが上にスクロールすると、アプリ・バーが消えるのがわかるが、下にスクロールし直すと、ユーザーがリストのどこにいてもアプリ・バーが戻ってくる必要がある。"
  },
  {
    "start": 902240,
    "end": 906240,
    "text": "フローティング・プロパティをtrueに設定する必要がある。"
  },
  {
    "start": 906240,
    "end": 915240,
    "text": "その上にカーソルを置くと、ユーザーがアプリバーに向かってスクロールし始めるとすぐにアプリバーが表示されることがわかります。"
  },
  {
    "start": 915240,
    "end": 919240,
    "text": "ビデオカードのリストを追加してみよう。"
  },
  {
    "start": 919240,
    "end": 925240,
    "text": "カスタムスクロールビューにいるため、SliverListを使用する必要があります。"
  },
  {
    "start": 925240,
    "end": 938240,
    "text": "ホーム画面の内部では、customSliverAppBar の後に SliverList を作成することができ、これには SliverChildBuilderDelegate と呼ばれるデリゲートがあります。"
  },
  {
    "start": 938240,
    "end": 948240,
    "text": "これにより、コンテキストとインデックスが返され、これを使用して、ListViewBuilderのように各ビデオカードを実際に構築することができる。"
  },
  {
    "start": 948240,
    "end": 958240,
    "text": "finalVideoがvideosインデックスと等しく、videosがdata.dartから取得される。"
  },
  {
    "start": 958240,
    "end": 966240,
    "text": "ビデオカードを返却することもできるし、ビデオを渡すこともできる。"
  },
  {
    "start": 966240,
    "end": 971240,
    "text": "子プロセスのカウントをvideos.lengthに設定することを忘れないでください。"
  },
  {
    "start": 971240,
    "end": 979240,
    "text": "ビデオカードはWidgetsフォルダの中で定義します。"
  },
  {
    "start": 979240,
    "end": 997240,
    "text": "スタットレス・ビデオカードで素材をインポートし、ウィジェットでエクスポートしてビデオを取り込む。"
  },
  {
    "start": 997240,
    "end": 1003240,
    "text": "data.dartをインポートし、コンストラクタを生成する。"
  },
  {
    "start": 1003240,
    "end": 1012240,
    "text": "各ビデオカードはカラムウィジェットになり、まずスタックウィジェットで画像を表示し、右下にタイムスタンプを表示する。"
  },
  {
    "start": 1012240,
    "end": 1024240,
    "text": "サークルのアバターがある行ウィジェットがあり、ビデオのタイトルと作者、再生回数や時間前などの追加情報がある列ウィジェットがある。"
  },
  {
    "start": 1024240,
    "end": 1027240,
    "text": "そしてこの右側にアイコンがある。"
  },
  {
    "start": 1027240,
    "end": 1035240,
    "text": "まずカラム・ウィジェット全体を作成し、次にタイムスタンプ付きのサムネイルを作成することに集中しよう。"
  },
  {
    "start": 1035240,
    "end": 1047240,
    "text": "これをcolumn, childrenに変更し、image.networkを追加します。ソースは、渡されたビデオ、thumbnail.urlになります。"
  },
  {
    "start": 1047240,
    "end": 1050240,
    "text": "高さは220.0とする。"
  },
  {
    "start": 1050240,
    "end": 1056240,
    "text": "幅は2倍の無限大ドットとなり、列の幅全体に広がる。"
  },
  {
    "start": 1056240,
    "end": 1062240,
    "text": "その場合、fitはboxfit.coverとなる。"
  },
  {
    "start": 1062240,
    "end": 1065240,
    "text": "これで3つのサムネイルが揃った。"
  },
  {
    "start": 1065240,
    "end": 1074240,
    "text": "右下にタイムスタンプを追加するために、image.networkを別のカラムで囲み、このカラムをスタックに変更しよう。"
  },
  {
    "start": 1074240,
    "end": 1085240,
    "text": "ここから、下を8.0、右を8.0としてポジションを追加することができる。"
  },
  {
    "start": 1085240,
    "end": 1118240,
    "text": "子ウィジェットはコンテナ・ウィジェットで、色はcolors.black、子ウィジェットはテキストで、video.duration、スタイルはtheme.ofcontext.texttheme、キャプションはcopy width、色はcolors.whiteです。"
  },
  {
    "start": 1118240,
    "end": 1125240,
    "text": "テキストテーマを使ったことがない場合は、下の説明文にテキストテーマに関する資料へのリンクを貼っておきます。"
  },
  {
    "start": 1125240,
    "end": 1132240,
    "text": "コンテナにパディングを加えることができる。const edinsets.all 4.0。"
  },
  {
    "start": 1132240,
    "end": 1137240,
    "text": "これでタイムスタンプ付きのサムネイルが完成した。"
  },
  {
    "start": 1137240,
    "end": 1147240,
    "text": "次に、サークルアバター、タイトル、ビデオ情報、アイコンがあるこの下の行ウィジェットに注目してみましょう。"
  },
  {
    "start": 1147240,
    "end": 1166240,
    "text": "スタックの下に、行ウィジェットを作成し、サークルアバターを配置します。"
  },
  {
    "start": 1166240,
    "end": 1180240,
    "text": "onTapでサークルアバターをジェスチャー検出器にラップすることができます。"
  },
  {
    "start": 1180240,
    "end": 1189490,
    "text": "サークルアバターの右側には、2つのテキストウィジェット、テキストを含む別のカラムがあります、"
  },
  {
    "start": 1189490,
    "end": 1211120,
    "text": "videoTitle、テキスト、video.author.username、そしてMacのオプション8、view.viewCount、またはvideo.viewCountを箇条書きで追加します、"
  },
  {
    "start": 1211120,
    "end": 1221240,
    "text": "というより、再生回数、もうひとつの弾丸、そしてvideo.timestampだ。"
  },
  {
    "start": 1221240,
    "end": 1222240,
    "text": "それは取っておこう。"
  },
  {
    "start": 1222240,
    "end": 1230240,
    "text": "今、オーバーフローエラーが出ているのがわかると思うが、それを処理する前に、実際にtimeagoパッケージの使い方を考えてみよう。"
  },
  {
    "start": 1230240,
    "end": 1246240,
    "text": "このパッケージを使うには、このファイルの一番上にあるtimeagoパッケージをインポートする必要がある、"
  },
  {
    "start": 1246240,
    "end": 1251240,
    "text": "これをtimeagoと呼ぶことにする。"
  },
  {
    "start": 1251240,
    "end": 1261240,
    "text": "あとはtimeago.formatと入力して、動画のタイムスタンプを渡すだけだ。"
  },
  {
    "start": 1262240,
    "end": 1274240,
    "text": "crossAxisAlignmentをcrossAxisAlignment.startに設定し、両方のテキスト・ウィジェットが左寄せになるようにして、オーバーフロー・エラーを修正しよう、"
  },
  {
    "start": 1274240,
    "end": 1283240,
    "text": "これら両方のテキスト・ウィジェットを2行までオーバーフローさせ、省略記号で切り捨てる。"
  },
  {
    "start": 1283240,
    "end": 1297240,
    "text": "これらのテキスト・ウィジェットをそれぞれflexibleで囲み、maxLinesを2行に設定しよう。"
  },
  {
    "start": 1297240,
    "end": 1305240,
    "text": "OverflowはtextOverflow.ellipsisとし、これら両方に対してこれを行う。"
  },
  {
    "start": 1305240,
    "end": 1317240,
    "text": "次に、列のmainAxisSizeをmainAxisSize.minに設定する必要があります。これは、列の垂直方向の高さができるだけ小さくなるようにするためです。"
  },
  {
    "start": 1317240,
    "end": 1325240,
    "text": "カラムを拡張ウィジェットの中に入れれば解決する。"
  },
  {
    "start": 1325240,
    "end": 1343240,
    "text": "これらのテキスト・ウィジェットに、style theme.ofのcontextTextTheme、bodyText1.copyWith、fontSize 15.0を設定してスタイルを設定しよう。"
  },
  {
    "start": 1343240,
    "end": 1355240,
    "text": "ユーザー名、viewCount、タイムスタンプはtextTheme.captionとなり、fontSizeは14.0となります。"
  },
  {
    "start": 1355240,
    "end": 1367240,
    "text": "constのsizedBoxを8.0にすることで、展開された列と円のアバターの間に間隔を追加することができます。"
  },
  {
    "start": 1367240,
    "end": 1372240,
    "text": "行ウィジェットをパディングで囲んで、もう少しスペースを確保しましょう。"
  },
  {
    "start": 1372240,
    "end": 1377240,
    "text": "EdgeInsets.all 12.0。"
  },
  {
    "start": 1377240,
    "end": 1384240,
    "text": "最後にアイコンを追加する必要があるが、このアイコンは縦長のアイコンである。"
  },
  {
    "start": 1384240,
    "end": 1395240,
    "text": "Iconicons.Morevertsize 20.0。"
  },
  {
    "start": 1395240,
    "end": 1401240,
    "text": "タップする機能を実装したい場合に備えて、ジェスチャー検出器にこれをラッピングする必要がある。"
  },
  {
    "start": 1401240,
    "end": 1410240,
    "text": "ここでアイコンボタンを使っていないのは、アイコンボタンにはデフォルトでパディングがあるからです。"
  },
  {
    "start": 1410240,
    "end": 1415240,
    "text": "UIに合わせるために、行ウィジェットの各項目を一番上に揃える必要があります。"
  },
  {
    "start": 1415240,
    "end": 1424240,
    "text": "したがって、行ウィジェットのcrossAxisAlignmentをcrossAxisAlignment.startに設定することができる。"
  },
  {
    "start": 1424240,
    "end": 1431240,
    "text": "mainAxisAlignmentをmainAxisAlignment.spaceBetweenに設定する。"
  },
  {
    "start": 1431240,
    "end": 1437240,
    "text": "右のアイコンが右端まで押されるようにする。"
  },
  {
    "start": 1437240,
    "end": 1442240,
    "text": "これが、今のところビデオカードに必要なことのすべてだ。"
  },
  {
    "start": 1442240,
    "end": 1447240,
    "text": "このミニプレーヤーを追加する前に、どのビデオが選択されているかを知る必要がある。"
  },
  {
    "start": 1447240,
    "end": 1451240,
    "text": "先ほども言ったように、私たちはRiverPodを使って州を管理するつもりだ。"
  },
  {
    "start": 1451240,
    "end": 1459240,
    "text": "ユーザーがこれらの動画のいずれかをタップするたびに、選択された動画の状態が更新されるようにします。"
  },
  {
    "start": 1459240,
    "end": 1468240,
    "text": "もしユーザーがこのXボタンをタップしたら、選択されたビデオの状態をNULLにしたい。"
  },
  {
    "start": 1468240,
    "end": 1470240,
    "text": "ナビ画面に入ってみよう。"
  },
  {
    "start": 1470240,
    "end": 1486240,
    "text": "finalSelectedVideoProviderを定義し、SQLをvideo型のステート・プロバイダーに設定する。"
  },
  {
    "start": 1486240,
    "end": 1491240,
    "text": "ビデオは無効である可能性があるため、ここにクエスチョンマークを付けている。"
  },
  {
    "start": 1491240,
    "end": 1498240,
    "text": "なぜなら、アプリを最初に起動したとき、ビデオは選択されていないからだ。"
  },
  {
    "start": 1498240,
    "end": 1501240,
    "text": "data.dartをインポートする。"
  },
  {
    "start": 1501240,
    "end": 1504240,
    "text": "これが国家運営の鍵だ。"
  },
  {
    "start": 1504240,
    "end": 1516240,
    "text": "ステート・プロバイダーにアクセスするには、main.dartに戻って、MyAppをプロバイダー・スコープの中にラップする必要がある。"
  },
  {
    "start": 1516240,
    "end": 1521240,
    "text": "プロバイダーのスコープにより、アプリ内のどこにいてもプロバイダーにアクセスできます。"
  },
  {
    "start": 1521240,
    "end": 1533240,
    "text": "ビデオカードに移動すると、ビデオカード・ウィジェット全体、つまりここの列をonTapでジェスチャー検出器にラップできる。"
  },
  {
    "start": 1533240,
    "end": 1540240,
    "text": "context.readを使って、選択したビデオ・プロバイダにアクセスできる。"
  },
  {
    "start": 1540240,
    "end": 1545240,
    "text": "context.readを使うには、RiverPodがインポートされていることを確認する必要がある。"
  },
  {
    "start": 1545240,
    "end": 1550240,
    "text": "flutter-riverpodをインポートする。"
  },
  {
    "start": 1550240,
    "end": 1557240,
    "text": "タップされたビデオにビデオであるステートを設定すればいい。"
  },
  {
    "start": 1557240,
    "end": 1562240,
    "text": "これが正しく機能していることを確認するために、ナビ画面に戻ってみよう。"
  },
  {
    "start": 1562240,
    "end": 1568240,
    "text": "スタックをconsumerと呼ばれるウィジェットの中に包みます。"
  },
  {
    "start": 1568240,
    "end": 1583240,
    "text": "このコンシューマーにはビルダーがあり、ビルド・コンテキストを返してくれる。ウォッチと呼ばれるもので、最後のコールバック・パラメーターはウィジェットだ。"
  },
  {
    "start": 1583240,
    "end": 1595240,
    "text": "スタックをこの中に移し、スタックを戻そう。"
  },
  {
    "start": 1595240,
    "end": 1601240,
    "text": "プロバイダー・スコープを追加したので、アプリをホット・リスタートする必要がある。"
  },
  {
    "start": 1601240,
    "end": 1616240,
    "text": "選択されたビデオを取得するには、final.selectedVideoを実行し、それをwatchと等しく設定すればよい。"
  },
  {
    "start": 1616240,
    "end": 1619240,
    "text": "選んだビデオをここにプリントアウトしておこう。"
  },
  {
    "start": 1619240,
    "end": 1629240,
    "text": "デバッグ・コンソールに移動してクリアすると、これらのビデオをクリックするたびに、コンソールが更新されるのがわかります。"
  },
  {
    "start": 1629240,
    "end": 1640240,
    "text": "この行が意味するのは、選択されているビデオ・プロバイダーが更新され、新しいビデオが選択されるたびに、UIのこのセクションを再構築するということだ。"
  },
  {
    "start": 1640240,
    "end": 1651240,
    "text": "なぜなら、ミニプレーヤーはスタック・ウィジェットの一部であり、一番下のナビゲーション・バーの真上に位置するからです。"
  },
  {
    "start": 1651240,
    "end": 1655240,
    "text": "このミニプレーヤーの追加に取りかかろう。"
  },
  {
    "start": 1655240,
    "end": 1659240,
    "text": "ここでprint文を削除すればいい。"
  },
  {
    "start": 1659240,
    "end": 1670240,
    "text": "画面のスタックを作成したら、dot dot add mini playerでミニプレーヤーを追加します。"
  },
  {
    "start": 1670240,
    "end": 1674240,
    "text": "ミニプレーヤー・パッケージをインポートする必要がある。"
  },
  {
    "start": 1674240,
    "end": 1682240,
    "text": "これは、ユーザーがミニプレーヤーをドラッグしたり、タップしたりすると、スクリーンの高さいっぱいに拡大する必要があるためです。"
  },
  {
    "start": 1682240,
    "end": 1691240,
    "text": "最大高さは、コンテキストのメディアクエリドットとなる。"
  },
  {
    "start": 1691240,
    "end": 1697240,
    "text": "その場合、最小の高さも必要で、これはアンダースコア・プレーヤーの最小の高さになる。"
  },
  {
    "start": 1697240,
    "end": 1702240,
    "text": "ここで定義しておこう。"
  },
  {
    "start": 1702240,
    "end": 1707240,
    "text": "静的constダブルプレーヤーの最小高さ。"
  },
  {
    "start": 1708240,
    "end": 1714240,
    "text": "これを60.0に設定しよう。"
  },
  {
    "start": 1714240,
    "end": 1720240,
    "text": "ミニプレーヤーにもビルダーパラメーターが必要で、これは背中の高さとパーセンテージを与えてくれる。"
  },
  {
    "start": 1720240,
    "end": 1729240,
    "text": "heightはミニプレーヤーの現在の高さ、percentageは最大高さに対するパーセンテージです。"
  },
  {
    "start": 1729240,
    "end": 1735240,
    "text": "とりあえず、中央にテキスト・ウィジェットを配置したコンテナ・ウィジェットを返してみよう。"
  },
  {
    "start": 1735240,
    "end": 1742240,
    "text": "高さとパーセンテージを出力させることができる。"
  },
  {
    "start": 1742240,
    "end": 1753240,
    "text": "今現在、ミニ・プレーヤーがパラメータ・タイプのoffstageに割り当てられないというエラーが出ています。これは、リストにカーソルを合わせると、offstageのリストであることがわかるからです。"
  },
  {
    "start": 1753240,
    "end": 1759240,
    "text": "ミニプレーヤーをオフステージ・ウィジェットの中にラップする必要があります。"
  },
  {
    "start": 1759240,
    "end": 1768240,
    "text": "選択した動画が NULL でない場合にのみ、ミニ プレーヤを表示します。"
  },
  {
    "start": 1768240,
    "end": 1775240,
    "text": "選択された動画が NULL の場合、offstage は真になり、このウィジェットは非表示になります。"
  },
  {
    "start": 1775240,
    "end": 1787240,
    "text": "コンテナの色をコンテクスト・ドット足場の背景色のカラーテーマ・ドットに設定しよう。"
  },
  {
    "start": 1787240,
    "end": 1790240,
    "text": "これで高さとパーセンテージを見ることができる。"
  },
  {
    "start": 1790240,
    "end": 1795240,
    "text": "このパネルを上にスライドさせると、高さとパーセンテージがそれに応じて変化しているのがわかる。"
  },
  {
    "start": 1795240,
    "end": 1799240,
    "text": "最大の高さに達すると、実際にカチッとはまる。"
  },
  {
    "start": 1799240,
    "end": 1807240,
    "text": "タップするか下にドラッグしてミニプレーヤーの高さを最小にすることができる。"
  },
  {
    "start": 1807240,
    "end": 1814240,
    "text": "ビルダーで最初にチェックしなければならないのは、selected videoがnullと等しくないことを確認することだ。"
  },
  {
    "start": 1814240,
    "end": 1818240,
    "text": "もしnullに等しければ、データをロードできないからだ。"
  },
  {
    "start": 1818240,
    "end": 1824240,
    "text": "ここでは、一定サイズのボックス・ドット縮小を返すことができる。"
  },
  {
    "start": 1824240,
    "end": 1831240,
    "text": "アプリをホットリスタートすると、ミニプレーヤーが消えているのがわかる。"
  },
  {
    "start": 1831240,
    "end": 1839240,
    "text": "これらの動画の一つをタップすると、ミニプレーヤーが表示されます。"
  },
  {
    "start": 1839240,
    "end": 1841240,
    "text": "これで、作業を開始する準備が整った。"
  },
  {
    "start": 1841240,
    "end": 1851240,
    "text": "ミニプレーヤーの高さは60で、この行ウィジェットの下にリニア・プログレス・インジケータを表示するので、列ウィジェットです。"
  },
  {
    "start": 1851240,
    "end": 1857240,
    "text": "コンテナの子はカラム、childrenになる。"
  },
  {
    "start": 1857240,
    "end": 1861240,
    "text": "まず、リニア・プログレス・インジケーターを追加しよう。"
  },
  {
    "start": 1861240,
    "end": 1866240,
    "text": "線形進捗インジケータの値は0.4。"
  },
  {
    "start": 1866240,
    "end": 1880240,
    "text": "色を設定するために、それは単に値の色、常に停止したアニメーション、色、色のドット赤です。"
  },
  {
    "start": 1880240,
    "end": 1884240,
    "text": "これで、インジケーターが表示されたことがわかる。"
  },
  {
    "start": 1884240,
    "end": 1890240,
    "text": "行ウィジェット、行の子ウィジェットを追加しましょう。"
  },
  {
    "start": 1890240,
    "end": 1898240,
    "text": "私たちは、イメージネットワーク、選択したビデオドットサムネイルURLを持っているサムネイルを表示します。"
  },
  {
    "start": 1898240,
    "end": 1902240,
    "text": "高さは選手の最低身長から4.0を引いたものになる。"
  },
  {
    "start": 1902240,
    "end": 1912240,
    "text": "ここで4.0を引くのは、引かずにそのまま画像を表示させると、4ピクセルのオーバーフローエラーが発生するからだ。"
  },
  {
    "start": 1912240,
    "end": 1916240,
    "text": "リニア・プログレス・インジケーターはデフォルトで4ピクセルだからだ。"
  },
  {
    "start": 1916240,
    "end": 1920240,
    "text": "4.0をマイナスして、フィットすることを確認する必要がある。"
  },
  {
    "start": 1920240,
    "end": 1928240,
    "text": "幅は120.0、フィットはボックスフィットのドットカバーとなる。"
  },
  {
    "start": 1928240,
    "end": 1935240,
    "text": "次に、タイトル・テキストとビデオの作者を表示します。"
  },
  {
    "start": 1935240,
    "end": 1945240,
    "text": "またテキストを切り捨てる必要があるので、これはビデオカードのタイトルテキストやビデオ情報テキストで行ったことと非常に似ている。"
  },
  {
    "start": 1945240,
    "end": 1952240,
    "text": "そこに行って、展開されたコードをコピーしよう。"
  },
  {
    "start": 1952240,
    "end": 1960240,
    "text": "ナビ画面に戻り、この直後に貼り付ける。"
  },
  {
    "start": 1960240,
    "end": 1966240,
    "text": "選択したビデオでビデオを置き換える。"
  },
  {
    "start": 1966240,
    "end": 1972240,
    "text": "選択されたビデオは、消費者ウィジェットから取得したものです。"
  },
  {
    "start": 1972240,
    "end": 1978240,
    "text": "その後、watchを使って選択されたビデオプロバイダの状態を取得する。"
  },
  {
    "start": 1978240,
    "end": 1985240,
    "text": "あとはここで削除すればいい。"
  },
  {
    "start": 1985240,
    "end": 1995240,
    "text": "デフォルトでは各テキストの最大行数は1なので、実際に定義する必要はない。"
  },
  {
    "start": 1995240,
    "end": 2014240,
    "text": "テキスト・テーマ・ドット・キャプションでスタイルを編集し、フォント・ウェイトでコピーして、フォント・ウェイトを500、カラーをドット・ホワイトにします。"
  },
  {
    "start": 2014240,
    "end": 2022240,
    "text": "フォント・ウェイトをここにコピーして、ユーザー名が一致することを確認しよう。"
  },
  {
    "start": 2022240,
    "end": 2029240,
    "text": "カラムをパディング・ウィジェットで囲んでみよう。"
  },
  {
    "start": 2029240,
    "end": 2038240,
    "text": "あとは2つのアイコンボタンを追加するだけだ。"
  },
  {
    "start": 2038240,
    "end": 2049239,
    "text": "アイコンボタン、constアイコン、アイコンドットプレイ矢印、onPressedは空になります。"
  },
  {
    "start": 2049239,
    "end": 2055239,
    "text": "これをコピーして、これはアイコンドットクローズにしよう。"
  },
  {
    "start": 2055239,
    "end": 2061239,
    "text": "このonPressedでは、Xをクリックするとミニプレーヤーが消えるようにします。"
  },
  {
    "start": 2061239,
    "end": 2074239,
    "text": "コンテキスト・ドット・リードのselected video providerは、nullに等しい状態を持つ必要がある。"
  },
  {
    "start": 2074240,
    "end": 2082240,
    "text": "保存して、これをクリックすると、消えるのがわかる。"
  },
  {
    "start": 2082240,
    "end": 2090240,
    "text": "これでユーザーがこれらのサムネイルのどれかをタップすると、それに応じてミニプレーヤーが更新されることがわかります。"
  },
  {
    "start": 2090240,
    "end": 2096240,
    "text": "理想的なのは、ユーザーがこれらのビデオカードのどれかをタップすると、ビデオ画面に展開されることだ。"
  },
  {
    "start": 2096240,
    "end": 2105240,
    "text": "サムネイルがフルサイズになり、ビデオ情報が表示される。"
  },
  {
    "start": 2105240,
    "end": 2110240,
    "text": "ミニプレーヤーをタップで全高に広げるには、ミニプレーヤーコントローラーを追加する必要があります。"
  },
  {
    "start": 2110240,
    "end": 2120240,
    "text": "ビデオ画面とホーム画面でこのミニプレーヤーコントローラーにアクセスする必要があるため、プロバイダーを介してこのミニプレーヤーコントローラーにアクセスする必要があります。"
  },
  {
    "start": 2120240,
    "end": 2139240,
    "text": "ミニプレーヤーコントローラのプロバイダを作成し、ミニプレーヤーコントローラタイプのステートプロバイダに等しく設定します。"
  },
  {
    "start": 2141240,
    "end": 2144240,
    "text": "これは小文字のpであるべきだ。"
  },
  {
    "start": 2144240,
    "end": 2151240,
    "text": "自動廃棄をタップすると、ミニプレーヤー・コントローラーが不要になったときに廃棄されます。"
  },
  {
    "start": 2151240,
    "end": 2160240,
    "text": "ミニプレーヤーに下りて、コントローラー・パラメーターを追加し、ミニプレーヤー・コントローラーに等しく設定します。"
  },
  {
    "start": 2160240,
    "end": 2164240,
    "text": "選択したビデオのすぐ下にこの変数を定義する。"
  },
  {
    "start": 2164240,
    "end": 2174240,
    "text": "final、ミニプレーヤーコントローラは、watch、ミニプレーヤーコントローラプロバイダ、ドットステートと等しい。"
  },
  {
    "start": 2174240,
    "end": 2196240,
    "text": "この意味は、ビデオカードに入り、ユーザーがビデオをタップするたびに、context.read、mini player controller、provider、dot stateを実行し、animateToHeightメソッドを呼び出すことができるということです。"
  },
  {
    "start": 2196240,
    "end": 2200240,
    "text": "animateToHeightは、高さ、パネルの状態、持続時間を受け取ります。"
  },
  {
    "start": 2200240,
    "end": 2202240,
    "text": "私たちはパネルの状態を気にしている。"
  },
  {
    "start": 2202240,
    "end": 2211240,
    "text": "ステートを定義し、パネル・ステートにドット・マックスを渡そう。ドット・マックスは、ミニ・プレーヤーをスクリーンの高さいっぱいまで拡大させる。"
  },
  {
    "start": 2212240,
    "end": 2226240,
    "text": "アプリをホットリスタートし、これらのサムネイルの1つをクリックすると、ミニプレーヤーが全体の高さに拡大され、すべてのサムネイルで機能することがわかります。"
  },
  {
    "start": 2226240,
    "end": 2234240,
    "text": "もうひとつ、リスト・ビューの下部にパディングを追加する必要がある。"
  },
  {
    "start": 2234240,
    "end": 2254240,
    "text": "ホーム画面の中で、スライバー・リストをスライバー・パディングで包み、パディングをconst edgeInsets.onlyBottomとし、これを60.0に設定し、childをスライバーに変更しよう。"
  },
  {
    "start": 2254240,
    "end": 2258240,
    "text": "この中から一つを選ぶと、かなり見栄えが良くなる。"
  },
  {
    "start": 2258240,
    "end": 2264240,
    "text": "ミニプレーヤーが完全に展開されたら、ビデオ画面を表示したい。"
  },
  {
    "start": 2264240,
    "end": 2275240,
    "text": "videoscreen.dartという新しいファイルを作り、これをとりあえずvideoscreenというステートレス・ウィジェットにしよう。"
  },
  {
    "start": 2278240,
    "end": 2287240,
    "text": "ミニプレーヤーの拡大時にビデオ画面を表示できるようにする方法は、ビデオプレーヤーの現在の高さをチェックすることです。"
  },
  {
    "start": 2287240,
    "end": 2298240,
    "text": "ここでは、高さがplayerMinHeightの60に50.0を足した値以下であることをチェックします。"
  },
  {
    "start": 2298240,
    "end": 2302240,
    "text": "もしそうなら、ミニプレーヤーをここに表示します。"
  },
  {
    "start": 2302240,
    "end": 2307240,
    "text": "そうでなければ、実際にビデオ画面を表示したい。"
  },
  {
    "start": 2311240,
    "end": 2319240,
    "text": "これを保存して上にドラッグすると、先ほど定義したポイントを通過したときにビデオ画面になるのがわかる。"
  },
  {
    "start": 2319240,
    "end": 2324240,
    "text": "その後、下にドラッグするとミニプレーヤーに戻る。"
  },
  {
    "start": 2324240,
    "end": 2333240,
    "text": "前に見たように、ミニプレーヤーがリビルドされるたびに、このビルダーがトリガーされるからだ。"
  },
  {
    "start": 2333240,
    "end": 2336240,
    "text": "ビデオスクリーンの下に降りていこう。"
  },
  {
    "start": 2336240,
    "end": 2344240,
    "text": "最初にサムネイルを表示し、次にユーザーがタップしてビデオ画面を閉じることができるアイコンを表示します。"
  },
  {
    "start": 2344240,
    "end": 2349240,
    "text": "この下にはリニア・プログレス・インジケーターがある。"
  },
  {
    "start": 2349240,
    "end": 2353240,
    "text": "ビデオ画面を見てみよう。"
  },
  {
    "start": 2353240,
    "end": 2368240,
    "text": "これは雛形ウィジェットになり、ボディ、コンテナ、色はtheme.ofContext.scaffoldBackgroundColorになり、この子はカスタムスクロールビューになります。"
  },
  {
    "start": 2368240,
    "end": 2378240,
    "text": "これらの情報に加えて、この下にはシルバーリストもあるので、ユーザーは画面全体を連続的にスクロールすることができるからだ。"
  },
  {
    "start": 2378240,
    "end": 2385240,
    "text": "シュリンクラップをtrueに設定し、スライバーの定義を始めよう。"
  },
  {
    "start": 2385240,
    "end": 2399240,
    "text": "スライバをボックスに変換するアダプタを子機で用意し、ビデオに関する情報を取得するために、コンシューマ・ウィジェットを使用する必要がある。"
  },
  {
    "start": 2399240,
    "end": 2405240,
    "text": "消費者、ビルダー、そしてflutter-river-podのインポートを忘れずに。"
  },
  {
    "start": 2405240,
    "end": 2412240,
    "text": "Context、watch、そして最後のウィジェットは使わない。"
  },
  {
    "start": 2412240,
    "end": 2434240,
    "text": "選択されたビデオ、watchSelectedVideoProvider.state を取得し、列ウィジェットを返すことができます、"
  },
  {
    "start": 2434240,
    "end": 2452240,
    "text": "image.network、selectedVideo、thumbnailURL、heightは220.0、widthはdouble dot infinity、fitは前と同じくboxFit.cover。"
  },
  {
    "start": 2452240,
    "end": 2460240,
    "text": "サムネイルがステータスバーとぶつからないように、安全な場所にカラムを置くことができる。"
  },
  {
    "start": 2460240,
    "end": 2476240,
    "text": "左上にアイコンボタンを追加しよう。iconButton, icon, const icon, icons.keyboard, arrow down."
  },
  {
    "start": 2476240,
    "end": 2501240,
    "text": "アイコンのサイズを30.0に設定し、onPressedでcontext.read、miniPlayerControllerProvider.stateを呼び出し、miniPlayerControllerにアクセスして、animateToHeightを呼び出す。"
  },
  {
    "start": 2501240,
    "end": 2508240,
    "text": "アイコンをタップすると、パネルが縮小される。"
  },
  {
    "start": 2508240,
    "end": 2516240,
    "text": "スタック・ウィジェットの下に、リニア・プログレス・インジケーターを追加しましょう、"
  },
  {
    "start": 2516240,
    "end": 2528240,
    "text": "このコード・ブロックをここにリンクし、スタックの下に貼り付ける。"
  },
  {
    "start": 2528240,
    "end": 2531240,
    "text": "このビデオ情報をすべて追加する作業をしよう。"
  },
  {
    "start": 2531240,
    "end": 2535240,
    "text": "VideoInfoというウィジェットを作成し、3つの部分に分割します。"
  },
  {
    "start": 2535240,
    "end": 2545240,
    "text": "ここにテキスト情報があり、次にアクションの列、そしてビデオの作者に関する情報がある。"
  },
  {
    "start": 2545240,
    "end": 2552240,
    "text": "Widgetsフォルダの中にVideoInfo.dartという新しいウィジェットを作ってみよう。"
  },
  {
    "start": 2552240,
    "end": 2565240,
    "text": "これはステートレス・ウィジェットで、素材をインポートし、ビデオを取り込みます。"
  },
  {
    "start": 2565240,
    "end": 2575240,
    "text": "コンストラクタを生成し、widgets.dartに戻ってVideoInfoをエクスポートします。"
  },
  {
    "start": 2575240,
    "end": 2591240,
    "text": "ビデオ画面に移動して、リニア・プログレス・インジケータの直後にVideoInfoを表示し、選択したビデオを渡す。"
  },
  {
    "start": 2591240,
    "end": 2613240,
    "text": "まずカラム・ウィジェットから始めましょう。テキスト、ビデオ・タイトル、スタイルはtheme.ofContext.textTheme.bodyText1、コピー幅、フォント・サイズ15.0です。"
  },
  {
    "start": 2613240,
    "end": 2626415,
    "text": "その後、パディングを追加し、constサイズのボックスで、高さを8.0とし、テキスト、ビューカウントとします、"
  },
  {
    "start": 2626415,
    "end": 2636240,
    "text": "video.viewCount、views、それから箇条書きで、Macの場合はオプション8、Windowsの場合はよくわかりません、"
  },
  {
    "start": 2636240,
    "end": 2642240,
    "text": "timeAgo.format、 video.timestamp。"
  },
  {
    "start": 2642240,
    "end": 2652240,
    "text": "以前にも書いたが、timeAgoを取得するには、timeAgoパッケージをインポートする必要がある。"
  },
  {
    "start": 2652240,
    "end": 2666240,
    "text": "スタイルはtheme.ofContext.textTheme.captionとし、コピー幅、フォントサイズは14.0とする。"
  },
  {
    "start": 2666240,
    "end": 2676240,
    "text": "左揃えにするには、列の横軸アライメントをcrossAxisAlignment.startに設定する必要があります。"
  },
  {
    "start": 2676240,
    "end": 2684240,
    "text": "列をパディングで囲み、これを16.0にしよう。"
  },
  {
    "start": 2684240,
    "end": 2695240,
    "text": "次に、ここに仕切りを作り、アクションの行を作り、さらに仕切りを作ります。"
  },
  {
    "start": 2695240,
    "end": 2707240,
    "text": "テキストの下にはconst dividerがあり、それを複製して、現在のビデオを取り込むactionsRowというプライベート・ウィジェットを作ります。"
  },
  {
    "start": 2707240,
    "end": 2718240,
    "text": "ビデオ情報の下に、ステートレスのactionsRowを作ろう。ここでもアンダースコアを付けるとprivateになり、このファイル内でしかactionsRowにアクセスできなくなる。"
  },
  {
    "start": 2718240,
    "end": 2728240,
    "text": "ここでコードをコピーして、下に貼り付けます。"
  },
  {
    "start": 2728240,
    "end": 2735240,
    "text": "UIをよく見てみると、これらのアイコンとラベルはどれもよく似ている。"
  },
  {
    "start": 2735240,
    "end": 2743240,
    "text": "アイコンとラベルを指定するだけのアクションを作成する関数を作るのは理にかなっている。"
  },
  {
    "start": 2743240,
    "end": 2752240,
    "text": "これは、子ウィジェットを持つ行ウィジェットになる。"
  },
  {
    "start": 2752240,
    "end": 2765240,
    "text": "これはコンテキストを取り込み、アイコンを取り込み、最初のアイコンはThumbUpOutlinedで、次にラベルを取り込みます。"
  },
  {
    "start": 2765240,
    "end": 2768240,
    "text": "あと4回にしよう。"
  },
  {
    "start": 2768240,
    "end": 2777240,
    "text": "次に、VideoDislikes、ThumbDownOutlined、ReplyOutlinedがある。"
  },
  {
    "start": 2777240,
    "end": 2780240,
    "text": "ここでの文章はシェアとなる。"
  },
  {
    "start": 2782240,
    "end": 2788240,
    "text": "これはDownloadとなり、DownloadOutlinedアイコンが表示されます。"
  },
  {
    "start": 2788240,
    "end": 2791240,
    "text": "最後のアイコンはLibraryAddOutlinedになる。"
  },
  {
    "start": 2793240,
    "end": 2796240,
    "text": "セーブする。"
  },
  {
    "start": 2797240,
    "end": 2809240,
    "text": "buildActionはウィジェットを返し、buildContext、context、iconData、icon、stringLabelを受け取ります。"
  },
  {
    "start": 2810240,
    "end": 2822240,
    "text": "ジェスチャー検出器を返すことができるのは、このためにアイコンボタンを使っていないからであり、アイコンボタンにラベルを追加できないからである。"
  },
  {
    "start": 2822240,
    "end": 2828240,
    "text": "child、column、children、iconがあり、iconを渡す。"
  },
  {
    "start": 2828240,
    "end": 2837240,
    "text": "パディング用のサイズボックス、高さ6.0、そしてテキスト・ラベルを用意する。"
  },
  {
    "start": 2837240,
    "end": 2850240,
    "text": "ラベルのスタイル theme.ofContext、.textTheme、.caption、.copyWithColors、.white。"
  },
  {
    "start": 2853240,
    "end": 2868240,
    "text": "列にはmainAxisSize、mainAxisSizeMinを設定し、さらに行にはmainAxisAlignment、mainAxisAlignment、スペースを設定します。"
  },
  {
    "start": 2868240,
    "end": 2871240,
    "text": "彼らは広がっていく。"
  },
  {
    "start": 2872240,
    "end": 2875240,
    "text": "完璧だ。"
  },
  {
    "start": 2875240,
    "end": 2881240,
    "text": "動画情報をまとめるには、動画情報の一番下に作者情報を追加すればよい。"
  },
  {
    "start": 2881240,
    "end": 2890240,
    "text": "authorInfoという別のプライベートウィジェットを作ってみましょう。"
  },
  {
    "start": 2890240,
    "end": 2899240,
    "text": "これはユーザーを取り込み、行ウィジェットになります。"
  },
  {
    "start": 2899240,
    "end": 2902240,
    "text": "rowchildren。"
  },
  {
    "start": 2905240,
    "end": 2914240,
    "text": "まず、foregroundImage、networkImage、user.profileImageUrlを持つサークルアバターを用意します。"
  },
  {
    "start": 2914240,
    "end": 2923240,
    "text": "ここに戻れば、作者情報を追加し、video.authorを渡すことができる。"
  },
  {
    "start": 2923240,
    "end": 2929240,
    "text": "もう1つのコンスト・デバイダーを追加しよう。"
  },
  {
    "start": 2930240,
    "end": 2939240,
    "text": "この後、2つのテキスト・ウィジェットを表示し、両方の行のmaxLineを2にして、ビデオ・カードのように切り捨てる。"
  },
  {
    "start": 2939240,
    "end": 2954240,
    "text": "ビデオカードに入り、ここで展開したものをvideoInfoに戻って、circleAvatarの直後に貼り付けよう。"
  },
  {
    "start": 2955240,
    "end": 2967240,
    "text": "最初のものをuser.userNameに変更し、この下のものをuser.subscribers.subscribersにします。"
  },
  {
    "start": 2969240,
    "end": 2978240,
    "text": "これらの2つの間に、const sizedBox width 8.0でパディングを追加することができます。"
  },
  {
    "start": 2979240,
    "end": 2983845,
    "text": "最後に、右側にテキスト・ボタンを追加する必要がある。"
  },
  {
    "start": 2983845,
    "end": 3006240,
    "text": "TextButton、Onpressed、Childは購読したテキストウィジェットです。テキストをスタイルするので、theme.ofcontext .texttheme、bodytext1、copywidthをスタイルします。色をcolors.redに設定します。"
  },
  {
    "start": 3007240,
    "end": 3013240,
    "text": "本当は行の中にあるべきテキストボタンを列の中に入れてしまった。"
  },
  {
    "start": 3013240,
    "end": 3019240,
    "text": "展開した直後に移動させ、保存することができる。"
  },
  {
    "start": 3019240,
    "end": 3022240,
    "text": "今は右側にある。"
  },
  {
    "start": 3022240,
    "end": 3038240,
    "text": "最後に行うべきことは、行ウィジェットをジェスチャー検出器にラップすることです。ユーザーがこれをタップした場合、ユーザーのプロフィールにナビゲートしたいからです。"
  },
  {
    "start": 3038240,
    "end": 3041240,
    "text": "これでビデオ情報はすべて終わった。"
  },
  {
    "start": 3041240,
    "end": 3050240,
    "text": "ビデオ画面のUIを仕上げるには、シルバーリストを追加し、提案されたオプションを表示すればいい。"
  },
  {
    "start": 3050240,
    "end": 3056240,
    "text": "ビデオ画面に入り、ここで多くのファイルを閉じることができる。"
  },
  {
    "start": 3058240,
    "end": 3074240,
    "text": "silver-to-boxアダプタの後、カスタムスクロールビューの中に、sliverList、デリゲート、sliverChildBuilderDelegateを追加すると、コンテキストとインデックスを返してくれる。"
  },
  {
    "start": 3079240,
    "end": 3094240,
    "text": "提案されたビデオ、インデックスからビデオを取得し、ビデオカードを返し、ビデオを渡すことができる。"
  },
  {
    "start": 3094240,
    "end": 3103240,
    "text": "提案されたvideos.lengthに子供の数を設定することを忘れないでください。"
  },
  {
    "start": 3103240,
    "end": 3109240,
    "text": "ここでスクロールすると、それぞれのカードを見ることができる。"
  },
  {
    "start": 3109240,
    "end": 3115240,
    "text": "各サムネイルにはサイドにパディングがあることが重要だ。"
  },
  {
    "start": 3115240,
    "end": 3121240,
    "text": "ホーム画面に戻ると、サイドにパッドがないことがわかる。"
  },
  {
    "start": 3121240,
    "end": 3130240,
    "text": "ここにパディングを追加するには、ビデオカードがhasPaddingブール値を取り込む必要がある。"
  },
  {
    "start": 3130240,
    "end": 3136240,
    "text": "これにはhasPaddingを設定し、trueを渡す。"
  },
  {
    "start": 3136240,
    "end": 3145240,
    "text": "ビデオカードでは、finalBoolのhasPaddingを取り込むので、デフォルト値としてfalseを設定する。"
  },
  {
    "start": 3145240,
    "end": 3160240,
    "text": "画像にパディングを追加するには、ここで画像をパディングで囲み、const edgeInsets.symmetric horizontalとします。"
  },
  {
    "start": 3160240,
    "end": 3182240,
    "text": "もしhasPaddingがtrueなら12.0を返し、そうでなければ0を返し、constを削除する。これを保存し、どれかをクリックすると、パディングがあることがわかる。"
  },
  {
    "start": 3182240,
    "end": 3188240,
    "text": "それは素晴らしい！ ここでタイムスタンプも修正しよう。"
  },
  {
    "start": 3188240,
    "end": 3194240,
    "text": "右からの位置はhasPadding 20.0でなければならない。"
  },
  {
    "start": 3194240,
    "end": 3197240,
    "text": "これはタイムスタンプを少しずらすだけである。"
  },
  {
    "start": 3200240,
    "end": 3203240,
    "text": "これでUIは完璧だ。"
  },
  {
    "start": 3203240,
    "end": 3212240,
    "text": "もうひとつ修正しなければならないことがある。それは、ビデオ画面でビデオカードを選択するときだ。"
  },
  {
    "start": 3212240,
    "end": 3218240,
    "text": "これらのカードのいずれかを選択して画面をタップすると、Facebookのクローンが選択されているのがわかる、"
  },
  {
    "start": 3218240,
    "end": 3224240,
    "text": "おそらく、ユーザーがそれを選択したことを知り、一番上までスクロールさせたいのだろう。"
  },
  {
    "start": 3224240,
    "end": 3233240,
    "text": "そのためには、ビデオカードに別の変数を追加する必要があり、これがavoidCallbackとなる。"
  },
  {
    "start": 3233240,
    "end": 3239240,
    "text": "ここでのアイデアは、onTapを持つということだ。onTapは実際にはnull可能なので、これはnullにすることができる。"
  },
  {
    "start": 3239240,
    "end": 3251240,
    "text": "ジェスチャー検出器の内部で、onTapがnullでないことをチェックして定義されていれば、onTapを呼び出します。"
  },
  {
    "start": 3251240,
    "end": 3254240,
    "text": "これを呼び出すには、感嘆符を付ける必要がある。"
  },
  {
    "start": 3255240,
    "end": 3264240,
    "text": "ユーザーがこれらのカードのいずれかをタップしたときに画面の上部にスクロールするには、ビデオ画面に戻ってスクロール・コントローラーを追加する必要がある。"
  },
  {
    "start": 3264240,
    "end": 3270240,
    "text": "このスクロールコントローラは、カスタムスクロールビューに取り付けられ、ユーザがビデオカードをタップしたときに表示されます、"
  },
  {
    "start": 3270240,
    "end": 3282240,
    "text": "この関数はスクロールコントローラにアクセスし、animateToメソッドを呼び出します。"
  },
  {
    "start": 3282240,
    "end": 3285240,
    "text": "今は空欄にしておいて、後で定義しよう。"
  },
  {
    "start": 3285240,
    "end": 3291240,
    "text": "この一番上に、ステートフル・ウィジェットに変換する scrollController を作成します。"
  },
  {
    "start": 3294240,
    "end": 3300240,
    "text": "initStateの中で、scrollControllerをscrollControllerと等しくする。"
  },
  {
    "start": 3302240,
    "end": 3305240,
    "text": "それを処分するためのdisposeメソッドを忘れてはならない。"
  },
  {
    "start": 3305240,
    "end": 3311240,
    "text": "もし scrollController が定義されていれば、 scrollController.dispose を呼び出せばいい。"
  },
  {
    "start": 3312240,
    "end": 3321240,
    "text": "に等しいコントローラを設定することで、 scrollController をカスタムスクロールビューにアタッチする必要があります。"
  },
  {
    "start": 3321240,
    "end": 3333240,
    "text": "scrollController.animateToにオフセットを渡して呼び出すことができる。オフセットは画面の一番上までスクロールさせたいので0になる。"
  },
  {
    "start": 3333240,
    "end": 3342240,
    "text": "持続時間はconstDurationとし、これを200ミリ秒に設定する。"
  },
  {
    "start": 3342240,
    "end": 3348240,
    "text": "そして最後にカーブはcurves.easeInとなる。"
  },
  {
    "start": 3350240,
    "end": 3353240,
    "text": "保存してホットリスタートしよう。"
  },
  {
    "start": 3355240,
    "end": 3363367,
    "text": "この中のひとつをクリックして下にスクロールし、チャットUIをタップすると、ビデオ画面が一番上にスクロールするのがわかる。"
  },
  {
    "start": 3363367,
    "end": 3367240,
    "text": "どれかをクリックすると、スクロールしてトップに戻る。"
  },
  {
    "start": 3367240,
    "end": 3376240,
    "text": "これにより、ユーザーは、ただビデオを選択して、新しいビデオを選択したことを知らせない代わりに、どのビデオが選択されたかを知ることができます。"
  },
  {
    "start": 3376240,
    "end": 3382240,
    "text": "ユーザーがビデオ情報のどこかをタップすると、ミニプレーヤーは自動的に最小サイズに縮小されます。"
  },
  {
    "start": 3382240,
    "end": 3388240,
    "text": "これを防ぐには、ジェスチャー検出器の中に雛形ウィジェットを入れます。"
  },
  {
    "start": 3388240,
    "end": 3394240,
    "text": "これはビデオ画面上のすべてのタップを上書きする。"
  },
  {
    "start": 3394240,
    "end": 3409240,
    "text": "context.readを呼び出し、ミニプレーヤーコントローラにアクセスし、statePanelState.maxでanimateToHeightを呼び出すだけです。"
  },
  {
    "start": 3409240,
    "end": 3415240,
    "text": "この中に入ってクリックしても、画面は最小化されない。"
  },
  {
    "start": 3415240,
    "end": 3421240,
    "text": "今は左上のボタンをタップすることでしか画面から出られない。"
  },
  {
    "start": 3422240,
    "end": 3425240,
    "text": "このビデオは以上だ。"
  },
  {
    "start": 3425240,
    "end": 3428240,
    "text": "YouTubeのユーザーインターフェースの作り方を学んだばかりだろう。"
  },
  {
    "start": 3428240,
    "end": 3443240,
    "text": "スライバー・アプリ・バー、ボトムナビゲーション・バー、ビデオカードの作成方法を学び、さらに素晴らしいミニプレーヤー・パッケージを使用して、ビデオを選択する際にこのような素晴らしいアニメーションを作成しました。"
  },
  {
    "start": 3443240,
    "end": 3456240,
    "text": "RiverPodを使用してアプリケーションの状態を管理する方法を学びました。 このプロジェクトを拡張し、ビデオプレーヤーを実装することに興味がある場合は、こちらをご覧ください、"
  },
  {
    "start": 3456240,
    "end": 3465240,
    "text": "NetflixのUIチュートリアルか、YouTubeのAPIとビデオプレーヤーのチュートリアルをご覧ください。"
  },
  {
    "start": 3465240,
    "end": 3468240,
    "text": "どちらの動画でもYouTubeの動画を再生する方法を紹介している。"
  },
  {
    "start": 3468240,
    "end": 3474240,
    "text": "もし楽しんでいただけたなら、いいね、コメント、購読をお忘れなく。"
  },
  {
    "start": 3474240,
    "end": 3480240,
    "text": "フルスタックのFlutter Firebaseコースについては、ご覧いただきありがとうございました。"
  }
]
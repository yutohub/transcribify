[
  {
    "start": 330,
    "end": 3162,
    "text": "160万％速い。"
  },
  {
    "start": 3226,
    "end": 7246,
    "text": "何も表示されないので、視覚的に表示することさえ難しい。"
  },
  {
    "start": 7348,
    "end": 11466,
    "text": "今日は、アルゴリズムの実行時間を改善するための7つのステップを紹介しよう。"
  },
  {
    "start": 11498,
    "end": 12442,
    "text": "これがキッカケだ。"
  },
  {
    "start": 12506,
    "end": 17262,
    "text": "最も遅いのはNのOで、最も速いのはやはりNのOだ。"
  },
  {
    "start": 17316,
    "end": 28758,
    "text": "その過程で、どんなアプリケーションでも使える一般的な最適化テクニックを使い、さらに少しエキゾチックになって、ビット操作の世界に入って本当にスピードアップを図ります。"
  },
  {
    "start": 28844,
    "end": 33720,
    "text": "そしてもちろん、コンパイラの最適化、SIMDなど、あらゆるものが猛烈に速くなる。"
  },
  {
    "start": 34090,
    "end": 37382,
    "text": "もちろん、問題は単純だ。"
  },
  {
    "start": 37436,
    "end": 44470,
    "text": "それはコード2022の登場によるもので、長い文字列の中から14個の異なる文字を探し出すというものだ。"
  },
  {
    "start": 44550,
    "end": 48890,
    "text": "14個の明確な文字を見つけたら、その文字の直後の位置を報告するだけだ。"
  },
  {
    "start": 48960,
    "end": 58106,
    "text": "アドベント・オブ・コード」をご存知でない方は、クリスマスの喜びをもたらすために問題を解決する、サンタをテーマにした楽しいホリデー・アドベンチャーのようなものだ。"
  },
  {
    "start": 58298,
    "end": 62318,
    "text": "最もシンプルな解決策は、ハッシュセットを使うことだろう？"
  },
  {
    "start": 62404,
    "end": 67618,
    "text": "最初の14文字を取得し、それらをすべてハッシュセットに放り込み、最後にハッシュセットの長さをチェックする。"
  },
  {
    "start": 67704,
    "end": 70114,
    "text": "もし14歳なら、自分たちでやるしかない。"
  },
  {
    "start": 70152,
    "end": 73986,
    "text": "そうでなければ、すべてを前進させて、もう一度やり直す必要がある。"
  },
  {
    "start": 74088,
    "end": 77458,
    "text": "もう一度、もう一度、もう一度、もう一度やってみる必要がある。"
  },
  {
    "start": 77544,
    "end": 79006,
    "text": "なんてことだ。"
  },
  {
    "start": 79048,
    "end": 81298,
    "text": "我々は14の明確なキャラクターを発見した。"
  },
  {
    "start": 81394,
    "end": 86998,
    "text": "あとは、この小さなJ、つまりJ番目のポジションを報告すれば、コードの冒険は解決だ。"
  },
  {
    "start": 87084,
    "end": 89030,
    "text": "とてもシンプルなコードだ。"
  },
  {
    "start": 89100,
    "end": 94486,
    "text": "単純に一度に14文字を超え、すべてをハッシュセットに集め、14文字の長さをチェックする。"
  },
  {
    "start": 94598,
    "end": 95530,
    "text": "ドカーン、終わった。"
  },
  {
    "start": 95600,
    "end": 104322,
    "text": "さて、非常に簡単な最適化があり、これが実行時間を92％高速化する最初の最適化である。"
  },
  {
    "start": 104406,
    "end": 107022,
    "text": "もちろん、それは文字を一文字ずつ挿入することである。"
  },
  {
    "start": 107076,
    "end": 113210,
    "text": "重複を検出した時点で、それ以上の処理は行わず、次の14セット目に進む。"
  },
  {
    "start": 113290,
    "end": 114602,
    "text": "ショックですよね？"
  },
  {
    "start": 114676,
    "end": 116174,
    "text": "92％速い。"
  },
  {
    "start": 116222,
    "end": 120990,
    "text": "このような単純なif文に対して、次のレベルの最適化を行おう。"
  },
  {
    "start": 121070,
    "end": 127326,
    "text": "これにより、走行時間は8.9倍に改善され、実質的に1桁速くなる。"
  },
  {
    "start": 127358,
    "end": 129750,
    "text": "私たちのやり方には驚かされるよ。"
  },
  {
    "start": 129820,
    "end": 133494,
    "text": "それはもちろん、ハッシュセットの代わりにベクトルを使うことだ。"
  },
  {
    "start": 133612,
    "end": 135842,
    "text": "少し直感に反するかもしれない。"
  },
  {
    "start": 135906,
    "end": 142646,
    "text": "なぜ、すべてのポジションをチェックした方がハッシュセットのルックアップより速いんだ？"
  },
  {
    "start": 142758,
    "end": 144682,
    "text": "それは一定の時間ではないのか？"
  },
  {
    "start": 144816,
    "end": 147574,
    "text": "そうだが、シングルベクタールックアップも同様だ。"
  },
  {
    "start": 147622,
    "end": 148922,
    "text": "それも一定の時間だ。"
  },
  {
    "start": 148976,
    "end": 150410,
    "text": "考えてほしいことがある。"
  },
  {
    "start": 150480,
    "end": 160494,
    "text": "ある一定の時間のビッグOを見たとき、それはある意味嘘で、実際はある一定のビッグOに1を掛けたものなのだ。"
  },
  {
    "start": 160612,
    "end": 162330,
    "text": "さて、その定数とは何だろう？"
  },
  {
    "start": 162410,
    "end": 169390,
    "text": "ハッシュセットとなると、その定数はベクトル定数よりもかなり大きくなる。"
  },
  {
    "start": 169470,
    "end": 170882,
    "text": "それで納得できるだろう？"
  },
  {
    "start": 170936,
    "end": 178882,
    "text": "なぜなら、ハッシュセットについて話しているときは、ハッシュとその中の大きなテーブルへのインデックスを計算しなければならないからだ。"
  },
  {
    "start": 178946,
    "end": 187266,
    "text": "その後、そのエントリーに行き、衝突がないかどうか、いくつかのカップル・アイテムのリストをスキャンして、同じかどうかをチェックしなければならない。"
  },
  {
    "start": 187378,
    "end": 196374,
    "text": "一方、ベクターの場合は、ハッシュセットのようにヒープ上でアロケートすることに変わりはないが、単に参照をたどってメモリ領域へのオフセットを計算するだけでいい。"
  },
  {
    "start": 196502,
    "end": 199830,
    "text": "それに比べれば、超高速になるだけだ。"
  },
  {
    "start": 199910,
    "end": 202358,
    "text": "コードはそれほど複雑ではない。"
  },
  {
    "start": 202454,
    "end": 209258,
    "text": "ハッシュ・セットの代わりにベクトルを作成し、insertの戻り値をチェックする代わりにcontainsを呼び出すだけでよい。"
  },
  {
    "start": 209354,
    "end": 213918,
    "text": "それほど大きな違いはないが、格段に速くなった。"
  },
  {
    "start": 214014,
    "end": 218974,
    "text": "同じコードをJavaScriptで書くと6.7倍速くなる。"
  },
  {
    "start": 219102,
    "end": 228174,
    "text": "一般的にリストの追加とチェックは、小規模なものではハッシュセットよりも格段に速いからだ。"
  },
  {
    "start": 228222,
    "end": 230658,
    "text": "小規模とは、14のようないくつかの項目を意味する。"
  },
  {
    "start": 230754,
    "end": 233974,
    "text": "よし、次に何をするかは明らかだろう。"
  },
  {
    "start": 234012,
    "end": 240022,
    "text": "これはもちろん、ベクトルの代わりに配列を使うことである。"
  },
  {
    "start": 240086,
    "end": 247318,
    "text": "スタックに割り当てられ、キャッシュの局所性のような利点が得られる。"
  },
  {
    "start": 247414,
    "end": 257070,
    "text": "なぜなら、14個の要素すべてを毎回チェックするのではなく、その一部だけをチェックしたいからだ。"
  },
  {
    "start": 257140,
    "end": 260538,
    "text": "それでも、以前の解決策と比べれば、さほど複雑ではない。"
  },
  {
    "start": 260634,
    "end": 266014,
    "text": "さて、この時点で、特に本物の言語を使ったことがない人にとっては、すべてが少し驚きであったことは分かっている。"
  },
  {
    "start": 266062,
    "end": 268702,
    "text": "本物の言語とは、静的配列を持つ言語を意味する。"
  },
  {
    "start": 268766,
    "end": 271902,
    "text": "JavaScript、配列バッファはどう？"
  },
  {
    "start": 271966,
    "end": 273458,
    "text": "落ち着いて。"
  },
  {
    "start": 273624,
    "end": 275682,
    "text": "まあ、そんな感じだけどね。"
  },
  {
    "start": 275736,
    "end": 279666,
    "text": "次の2、3の最適化は、ちょっと乱暴になりそうだ。"
  },
  {
    "start": 279778,
    "end": 285778,
    "text": "26倍速から233倍速になるんだ。"
  },
  {
    "start": 285874,
    "end": 289538,
    "text": "我々は猛烈に速いカテゴリーに入り始めている。"
  },
  {
    "start": 289634,
    "end": 295770,
    "text": "さて、この \"猛烈に速く \"という言葉を使う前に、まずは購読ボタンを押してください。"
  },
  {
    "start": 295840,
    "end": 303686,
    "text": "ビットについて説明しよう。ここから先は、超高速を得るためのビット操作がすべての解決策に含まれるからだ。"
  },
  {
    "start": 303718,
    "end": 310798,
    "text": "配列を使う必要がなくなったので、検索の状態を保存するために32ビットの単数値を使うことができる。"
  },
  {
    "start": 310884,
    "end": 318514,
    "text": "ASCII文字について理解しておかなければならないことのひとつは、それぞれの文字に関連する数値があり、それらはたまたま97から122まで連続しているということだ。"
  },
  {
    "start": 318552,
    "end": 323822,
    "text": "第2 AU 32は32ビットの符号なし数値である。"
  },
  {
    "start": 323886,
    "end": 333606,
    "text": "これは、32の位置に真か偽を格納する能力を持つ配列と考えることができ、真は1、偽は0である。"
  },
  {
    "start": 333708,
    "end": 343210,
    "text": "つまり、32でモジュロされた文字は、0から31の間の数字になる。"
  },
  {
    "start": 343280,
    "end": 344618,
    "text": "簡単な例を挙げてみよう。"
  },
  {
    "start": 344704,
    "end": 346570,
    "text": "検索状態がゼロだとしよう。"
  },
  {
    "start": 346640,
    "end": 351066,
    "text": "Dという文字を挿入したい。"
  },
  {
    "start": 351168,
    "end": 354718,
    "text": "Dまたは100の32乗は4である。"
  },
  {
    "start": 354804,
    "end": 358430,
    "text": "左シフト演算子は、10倍することに相当する。"
  },
  {
    "start": 358500,
    "end": 366754,
    "text": "つまり、これを4つずらすことで、10の2進数表現、ゼロ、または2進数10,000に等しくなる。"
  },
  {
    "start": 366872,
    "end": 376146,
    "text": "もし状態がゼロに等しく、それを今作った新しい2進数で表すと、結果の値は2進数10,000になる。"
  },
  {
    "start": 376248,
    "end": 378246,
    "text": "次のキャラクターがAだとしよう。"
  },
  {
    "start": 378348,
    "end": 382550,
    "text": "この式に従えば、2進数の10の値が得られる。"
  },
  {
    "start": 382620,
    "end": 387558,
    "text": "2進数10で計算すると、2進数10,010となる。"
  },
  {
    "start": 387644,
    "end": 392234,
    "text": "バイナリをセットする前に、そのバイナリがすでにセットされているかどうかを確認するには？"
  },
  {
    "start": 392272,
    "end": 394790,
    "text": "まあ、単純に論理演算子と演算子を使えばいいだけだ。"
  },
  {
    "start": 394870,
    "end": 400522,
    "text": "先ほどの例で言えば、and演算子を実行すれば、ゼロという値が得られる。"
  },
  {
    "start": 400656,
    "end": 404394,
    "text": "したがって、この2つの価値観に共通するものはない。"
  },
  {
    "start": 404512,
    "end": 407354,
    "text": "今、私はそれがバイナリーの非常に省略されたバージョンだったことを知っている。"
  },
  {
    "start": 407402,
    "end": 410954,
    "text": "もっと詳しく知りたければ、説明文にリンクを貼っておく。"
  },
  {
    "start": 411082,
    "end": 411934,
    "text": "見てきてください。"
  },
  {
    "start": 411972,
    "end": 413678,
    "text": "いいね！」ボタンの真下にある。"
  },
  {
    "start": 413764,
    "end": 417662,
    "text": "これがベニーのアルゴリズムで、実に賢い。"
  },
  {
    "start": 417726,
    "end": 424622,
    "text": "先ほど話したように、最初の13文字を取り出します。"
  },
  {
    "start": 424766,
    "end": 426254,
    "text": "これが秘伝のタレだ。"
  },
  {
    "start": 426302,
    "end": 428254,
    "text": "XORとxorを使う。"
  },
  {
    "start": 428302,
    "end": 429550,
    "text": "トグルのようなものだと思ってください。"
  },
  {
    "start": 429630,
    "end": 433190,
    "text": "そのビット位置にゼロがあれば、それを1に反転させる。"
  },
  {
    "start": 433260,
    "end": 439282,
    "text": "そのビット位置に1があれば、それを0に反転させる。"
  },
  {
    "start": 439346,
    "end": 443126,
    "text": "xorを使う以外は、先に示したのと同じ操作だ。"
  },
  {
    "start": 443238,
    "end": 447418,
    "text": "つまり、この時点で13人のキャラクターにトグルを入れたことになる。"
  },
  {
    "start": 447504,
    "end": 450586,
    "text": "ここからは、一度に14の入力を確認するだけだ。"
  },
  {
    "start": 450608,
    "end": 457294,
    "text": "ウインドウズの操作に馴染みがなければ、文字通り、ゼロから13、1から14、2から15と進む。"
  },
  {
    "start": 457412,
    "end": 459294,
    "text": "ちょうどいい窓になってくれる。"
  },
  {
    "start": 459332,
    "end": 464350,
    "text": "の場合、位置イテレータは最初の真の結果のインデックスを返す。"
  },
  {
    "start": 464500,
    "end": 471250,
    "text": "つまり、ここでtrueを返すと、その値ではなくインデックスが返される。"
  },
  {
    "start": 471320,
    "end": 474606,
    "text": "それでは、ウィンドウの最初と最後の文字を取得しよう。"
  },
  {
    "start": 474638,
    "end": 477490,
    "text": "さて、私たちの州には最初の13文字があることを思い出してほしい。"
  },
  {
    "start": 477570,
    "end": 480450,
    "text": "14番目の文字をトグルする。"
  },
  {
    "start": 480530,
    "end": 485430,
    "text": "今、私たちは州内に14のクラブを持つ可能性がある。"
  },
  {
    "start": 485500,
    "end": 490310,
    "text": "もし14本あれば、探しているポジションが見つかったことになる。"
  },
  {
    "start": 490380,
    "end": 492858,
    "text": "そして、最初に見た文字を削除する。"
  },
  {
    "start": 492944,
    "end": 497734,
    "text": "つまり、14個のトグルから13個のトグルへ、1個から13個へということだ。"
  },
  {
    "start": 497862,
    "end": 504426,
    "text": "そして、もう一度ループを繰り返し、ウィンドウの次の最後の項目を追加する。"
  },
  {
    "start": 504528,
    "end": 508222,
    "text": "これで1から14まで揃った。"
  },
  {
    "start": 508276,
    "end": 510398,
    "text": "そして1つ目を外し、2つ目に進む。"
  },
  {
    "start": 510484,
    "end": 513394,
    "text": "私たちは小さな窓を這うような動きを繰り返している。"
  },
  {
    "start": 513512,
    "end": 523790,
    "text": "この巧妙なアルゴリズムによって、ベニーはハッシュセットの233倍、つまり23,000％の速さを獲得した。"
  },
  {
    "start": 523870,
    "end": 526702,
    "text": "信じられないほど巧妙なアルゴリズムだ。"
  },
  {
    "start": 526766,
    "end": 528094,
    "text": "ベニーに脱帽だ。"
  },
  {
    "start": 528222,
    "end": 529182,
    "text": "くそっ、ベニー。"
  },
  {
    "start": 529246,
    "end": 530278,
    "text": "なんて賢い男なんだ。"
  },
  {
    "start": 530364,
    "end": 533926,
    "text": "私の解決策は、ハッシュセットのものより100倍速いだけだった。"
  },
  {
    "start": 533948,
    "end": 538258,
    "text": "ベニーの超賢明な窓を這う解決策を見ていると、とてもバカらしくなってくる。"
  },
  {
    "start": 538354,
    "end": 540186,
    "text": "ここで最終形に入ろう。"
  },
  {
    "start": 540208,
    "end": 544518,
    "text": "ベニーを4倍以上スピードアップさせたアルゴリズムを見てみよう。"
  },
  {
    "start": 544614,
    "end": 547990,
    "text": "およそ1000倍の速さだった。"
  },
  {
    "start": 548070,
    "end": 554042,
    "text": "アイデアを説明する代わりに、この最後のコードを見てみよう。"
  },
  {
    "start": 554106,
    "end": 559150,
    "text": "まず最初にすることは、ここで固定サイズのウィンドウを表示することだ。"
  },
  {
    "start": 559220,
    "end": 564522,
    "text": "indexからindexプラス14までgitで入力していることに気づくだろう。"
  },
  {
    "start": 564586,
    "end": 567002,
    "text": "これは一定の大きさのウィンドウである。"
  },
  {
    "start": 567066,
    "end": 568562,
    "text": "それを覚えておくことはとても重要だ。"
  },
  {
    "start": 568616,
    "end": 572190,
    "text": "次に、ベニーのソリューションと同じように、32ビットのステート変数を作る。"
  },
  {
    "start": 572270,
    "end": 576414,
    "text": "次に、そのスライスを逆に反復する。"
  },
  {
    "start": 576462,
    "end": 585334,
    "text": "さて、私個人としては、これを見たとき、イテレータを取り、すべてのエレメントを取得し、それらをすべて集めてから、それらのエレメントを逆向きに歩かなければならないことを意味する。"
  },
  {
    "start": 585372,
    "end": 587954,
    "text": "ベニーより速いわけがないと思った。"
  },
  {
    "start": 588002,
    "end": 589042,
    "text": "私たちも同じことをする。"
  },
  {
    "start": 589106,
    "end": 591338,
    "text": "ビットのモジュロ32を取る。"
  },
  {
    "start": 591424,
    "end": 595018,
    "text": "そのビットがすでに1にセットされているかどうかをテストする。"
  },
  {
    "start": 595104,
    "end": 596778,
    "text": "1に設定されている場合。"
  },
  {
    "start": 596864,
    "end": 598950,
    "text": "そして、重複する場所を見つけた。"
  },
  {
    "start": 599030,
    "end": 601878,
    "text": "次に、or演算子を使ってそのビットをシフトする。"
  },
  {
    "start": 601974,
    "end": 604638,
    "text": "そして、このバイトをすでに見たかどうかを返す。"
  },
  {
    "start": 604724,
    "end": 607594,
    "text": "これが2つあるうちの1つだ。"
  },
  {
    "start": 607722,
    "end": 615518,
    "text": "このバイトを見たのであれば、リストを逆行するのだから、実際にはこの位置プラス1までジャンプできる。"
  },
  {
    "start": 615604,
    "end": 617302,
    "text": "これは大きな最適化だ。"
  },
  {
    "start": 617386,
    "end": 621730,
    "text": "何度も見返す必要のない登場人物は何人かカットするつもりだ。"
  },
  {
    "start": 621800,
    "end": 627894,
    "text": "もし繰り返し文字が見つからなかったり、偽の条件であれば、実際にはこのインデックスを返す。"
  },
  {
    "start": 628012,
    "end": 631490,
    "text": "これは連続する14文字の位置である。"
  },
  {
    "start": 631570,
    "end": 633766,
    "text": "今、あなたはおそらく自問していることだろう。"
  },
  {
    "start": 633948,
    "end": 635382,
    "text": "見せてくれ、どうやるのか。"
  },
  {
    "start": 635436,
    "end": 641302,
    "text": "これはとても速かった。なぜリストを逆から見たほうが速いのか、その小さなジャンプ以外には理解できないからだ。"
  },
  {
    "start": 641366,
    "end": 643660,
    "text": "それでもすべてを反復しなければならないんだろう？"
  },
  {
    "start": 644030,
    "end": 644778,
    "text": "そうだね。"
  },
  {
    "start": 644944,
    "end": 645866,
    "text": "これを見てくれ"
  },
  {
    "start": 645888,
    "end": 646998,
    "text": "これがコンパイラー・エクスプローラーだ。"
  },
  {
    "start": 647014,
    "end": 648390,
    "text": "ここはgodbolt.orgだ。"
  },
  {
    "start": 648470,
    "end": 651866,
    "text": "まず、ベニーの解答をここに入れました。"
  },
  {
    "start": 651968,
    "end": 658734,
    "text": "さて、最初にお気づきになるのは、この入力が固定サイズであったため、コンパイラーはここで何をしたか、ということだ。"
  },
  {
    "start": 658772,
    "end": 661354,
    "text": "最適化の際、実際にループをアンロールした。"
  },
  {
    "start": 661402,
    "end": 663118,
    "text": "それですべてが一直線になった。"
  },
  {
    "start": 663204,
    "end": 667310,
    "text": "ジャンプバックして何度もやって、最後に飛び出すということはない。"
  },
  {
    "start": 667380,
    "end": 669518,
    "text": "そして、これがウィンドウズ14だ。"
  },
  {
    "start": 669614,
    "end": 672946,
    "text": "このループはとても興味深い。"
  },
  {
    "start": 672968,
    "end": 675490,
    "text": "この掟を何度も何度も繰り返すだけだ。"
  },
  {
    "start": 675560,
    "end": 677122,
    "text": "かなり速いだろ？"
  },
  {
    "start": 677176,
    "end": 679154,
    "text": "では、デービッドの解答を見てみよう。"
  },
  {
    "start": 679202,
    "end": 682518,
    "text": "デービッドの解決策と同じことがここで起こっている。"
  },
  {
    "start": 682604,
    "end": 684450,
    "text": "実際に巻き戻される。"
  },
  {
    "start": 684530,
    "end": 687414,
    "text": "逆イテレーターは、ここで逆に起こる。"
  },
  {
    "start": 687452,
    "end": 688374,
    "text": "すぐそこに見える。"
  },
  {
    "start": 688412,
    "end": 698762,
    "text": "1110、987-5321、それからこれが何を意味するのかわからないが、ここで起きていることはすべてSIMDのことだと聞いている。"
  },
  {
    "start": 698816,
    "end": 704234,
    "text": "つまり、1つの命令がコンパイラによって複数のデータ計算を一度に行うことになる。"
  },
  {
    "start": 704282,
    "end": 707310,
    "text": "つまり、やっていることを大幅にスピードアップできるということだ。"
  },
  {
    "start": 707380,
    "end": 713838,
    "text": "ベニーと違って内部ループがアンロールされているだけでなく、SIMD最適化も行われている。"
  },
  {
    "start": 714014,
    "end": 716674,
    "text": "この速さ、すさまじい。"
  },
  {
    "start": 716792,
    "end": 722366,
    "text": "待てよ、今のは16,000倍も速かったぞ。"
  },
  {
    "start": 722478,
    "end": 726334,
    "text": "いや、3桁以上速い。"
  },
  {
    "start": 726382,
    "end": 730242,
    "text": "1000倍速は983倍速だ。"
  },
  {
    "start": 730306,
    "end": 733110,
    "text": "どうしたら、あんなに稼げるんだろう？"
  },
  {
    "start": 733180,
    "end": 734450,
    "text": "もっと速い。"
  },
  {
    "start": 734530,
    "end": 737526,
    "text": "もちろん、私はただ何もしていない64本の糸を使っただけだ。"
  },
  {
    "start": 737548,
    "end": 737926,
    "text": "さあ、行こう。"
  },
  {
    "start": 737948,
    "end": 739110,
    "text": "もちろん、彼らはそうするだろう。"
  },
  {
    "start": 739180,
    "end": 742314,
    "text": "そのおかげで猛烈なスピードで走ることができた。"
  },
  {
    "start": 742432,
    "end": 746342,
    "text": "実際、オリジナル・ソリューションの16,000倍の速さだ。"
  },
  {
    "start": 746406,
    "end": 748938,
    "text": "誰かが、それってズルくない？"
  },
  {
    "start": 748944,
    "end": 749782,
    "text": "ちょっとズルいけど。"
  },
  {
    "start": 749846,
    "end": 751322,
    "text": "アルゴリズムの一部だろ？"
  },
  {
    "start": 751376,
    "end": 753450,
    "text": "我々はアルゴリズムを改良しているだけだ。"
  },
  {
    "start": 753530,
    "end": 756298,
    "text": "並列化するのは非常に単純な作業だ。"
  },
  {
    "start": 756394,
    "end": 758986,
    "text": "実際、グーグル・チャートが示すほどのスピードだ。"
  },
  {
    "start": 759098,
    "end": 762618,
    "text": "ここでは青いラインすら表示されないんだ。"
  },
  {
    "start": 762724,
    "end": 764130,
    "text": "それだけ速くなったということだ。"
  },
  {
    "start": 764200,
    "end": 785110,
    "text": "元のソリューションでは1秒間に3.84メガバイトのデータを処理していたのに対し、マルチスレッド化された最終的なソリューションでは1秒間に617ギガバイトのデータを処理していた。"
  },
  {
    "start": 785180,
    "end": 790646,
    "text": "もちろん、983倍速い解決策はデビッド・Aによってもたらされる。"
  },
  {
    "start": 790668,
    "end": 791170,
    "text": "ペレス"
  },
  {
    "start": 791250,
    "end": 792850,
    "text": "GitHubで彼をフォローしよう。"
  },
  {
    "start": 792930,
    "end": 795094,
    "text": "今のは猛烈に速い。"
  },
  {
    "start": 795212,
    "end": 796422,
    "text": "楽しんでいただけたなら幸いだ。"
  },
  {
    "start": 796476,
    "end": 797542,
    "text": "いいね！」ボタンを押してください。"
  },
  {
    "start": 797596,
    "end": 799046,
    "text": "下で教えてください。"
  },
  {
    "start": 799148,
    "end": 800926,
    "text": "とても楽しかった。"
  },
  {
    "start": 800948,
    "end": 802794,
    "text": "これは明らかにTwitchで行われたものだ。"
  },
  {
    "start": 802842,
    "end": 805040,
    "text": "最適化もすべてやった。"
  },
  {
    "start": 805810,
    "end": 807390,
    "text": "輝かしい時代だった。"
  },
  {
    "start": 807460,
    "end": 808366,
    "text": "ご視聴ありがとうございました。"
  },
  {
    "start": 808468,
    "end": 810090,
    "text": "その名はプリモゲン。"
  }
]